import:
	eos.moe.dragoncore.api.SlotAPI
	java.io.File
	java.util.ArrayList
	java.util.HashMap
	java.util.HashSet
	net.minecraft.server.v1_12_R1.PathfinderGoalSelector
	org.bukkit.attribute.Attribute
	org.bukkit.Bukkit
	org.bukkit.Color as BukkitColor
	org.bukkit.entity.EntityType
	org.bukkit.entity.HumanEntity
	org.bukkit.entity.Item
	org.bukkit.event.block.BlockBreakEvent
	org.bukkit.event.entity.EntityShootBowEvent
	org.bukkit.event.entity.ProjectileLaunchEvent
	org.bukkit.event.Event$Result as Result
	org.bukkit.event.player.PlayerDropItemEvent
	org.bukkit.event.player.PlayerItemDamageEvent
	org.bukkit.event.entity.PlayerLeashEntityEvent
	org.bukkit.event.player.PlayerVelocityEvent
	org.bukkit.event.vehicle.VehicleEntityCollisionEvent
	org.bukkit.inventory.ItemStack
	org.bukkit.Material
	org.bukkit.potion.PotionEffectType
	org.bukkit.util.Vector

on join:
	set {_ply} to event-player
	while {_ply} is online:
		if target of {_ply} is set:
			clear {_target}
			set {_target} to target of {_ply}
			if checkCanDamage({_ply}, {_target}) is true:
				set metadata "target" of {_ply} to {_target}
		if {_ply} has metadata "target":
			clear {_target}
			set {_target} to metadata "target" of {_ply}
			if world of {_target} is not world of {_ply}:
				clear metadata "target" of {_ply}
			else if distance between {_target} and {_ply} > 128:
				clear metadata "target" of {_ply}
			else if health of {_target} < 0.01:
				clear metadata "target" of {_ply}
			else if checkCanDamage({_ply}, {_target}) is false:
				clear metadata "target" of {_ply}
			else if {_target}.isDead() = true:
				clear metadata "target" of {_ply}
		wait 2 ticks


on leftclick:
	if event-block is set:
		set {_tool} to player's tool
		set {_toolName} to trimText(name of {_tool})
		set {_toolMat} to "%(getItem({_toolName})).getType()%"
		{_toolMat} ends with "PICKAXE"
		replace all "PICKAXE" in {_toolMat} with ""
		set {_blockType} to (event-block).getType().toString()
		if {_blockType} is "WORKBENCH" or "LOG" or "LOG_2" or "LADDER" or "PUMPKIN" or "CHEST" or "TRAPPED_CHEST" or "FENCE":
			set {_toolMat} to "%{_toolMat}%AXE"
		else if {_blockType} starts with "WOOD":
			set {_toolMat} to "%{_toolMat}%AXE"
		else if {_blockType} is "DIRT" or "GRASS" or "GRAVEL" or "SAND" or "MYCEL" or "GRASS_PATH" or "SOIL":
			set {_toolMat} to "%{_toolMat}%SPADE"
		else if {_blockType} is "WOOL" or "LEAVES" or "LEAVES_2":
			set {_toolMat} to "SHEARS"
		else:
			set {_toolMat} to "%{_toolMat}%PICKAXE"
		if {_toolMat} is not {_tool}.getType().toString():
			{_tool}.setType(Material.valueOf({_toolMat}))
			set player's tool to {_tool}
	if metadata "autoSwing" of player is true:
		if metadata "isLoadingWeapon" of player is true:
			set metadata "isLoadingWeapon" of player to false
			# fire loaded shots
			playerUseItem(player, (player's tool))
		set metadata "autoSwing" of player to false
		stop trigger
	else if metadata "useCD" of player is not true:
		playerUseItem(player, (player's tool))

function validateAmmo(ammo: item, itemName: text) :: boolean:
	if trimText(name of {_ammo}) is {_itemName}:
		return true
	if "%{_ammo}.getType()%" is {_itemName}:
		return true
	return false
function getAmmo(ply: player, itemName: text, consumptionRate: number) :: item:
	# in ammo slots
	set {_ammoInd} to 1
	loop 8 times:
		set {_ammo} to SlotAPI.getSlotItem({_ply}, "ammo%{_ammoInd}%", {_null})
		broadcast "%last java error%|%{_ammo}%"
		add 1 to {_ammoInd}
	# in void bag
	set {_ammoInd} to 0
	set {_ammoInv} to (metadata "inventories" of {_ply}).get("voidBag")
	loop 27 times:
		set {_ammo} to 1 of slot {_ammoInd} of {_ammoInv}
		if validateAmmo({_ammo}, {_itemName}) is true:
			if chance of {_chanceConsumption}:
				remove {_ammo} from slot {_ammoInd} of {_ammoInv}
			return {_ammo}
		add 1 to {_ammoInd}
	# in player inventory
	set {_ammoInd} to 0
	set {_ammoInv} to {_ply}'s inventory
	loop 36 times:
		set {_ammo} to 1 of slot {_ammoInd} of {_ammoInv}
		if validateAmmo({_ammo}, {_itemName}) is true:
			if chance of {_chanceConsumption}:
				remove {_ammo} from slot {_ammoInd} of {_ammoInv}
			return {_ammo}
		add 1 to {_ammoInd}
	return {_null}
		
function playerUseItem(ply: player, item: item):
	if {_ply} has metadata "effectTime诅咒":
		set metadata "autoSwing" of {_ply} to false
		set metadata "swingAmount" of {_ply} to 0
		stop trigger
	gamemode of {_ply} is not spectator
	if metadata "toolChanged" of {_ply} is true:
		set metadata "toolChanged" of {_ply} to false
		setPlayerStats({_ply})
	set {_itemType} to trimText(name of {_item})
	if {_itemType} contains "的 ":
		set {_prefix} to {_itemType}.split("的 ")[0]
		set {_itemType} to {_itemType}.split("的 ")[1]
	set {_weaponType} to yml value "%{_itemType}%.type" from file "plugins/Data/weapons.yml"
	{_weaponType} is set
	set {_autoSwing} to yml value "%{_itemType}%.autoSwing" from file "plugins/Data/weapons.yml"
	set {_projectileThruWall} to yml value "%{_itemType}%.thruWall" from file "plugins/Data/weapons.yml"
	set {_maxLoad} to yml value "%{_itemType}%.maxLoad" from file "plugins/Data/weapons.yml"
	set {_isLoading} to false
	if {_itemType} is "终极棱镜":
		if metadata "autoSwing" of {_ply} is not true:
			set metadata "swingAmount" of {_ply} to 0
	else if {_maxLoad} is set:
		set {_shotsLoaded} to 0
		if metadata "autoSwing" of {_ply} is not true:
			# start loading
			set metadata "swingAmount" of {_ply} to 0
			set metadata "isLoadingWeapon" of {_ply} to true
			set {_isLoading} to true
		else:
			if metadata "isLoadingWeapon" of {_ply} is true:
				# loading
				set {_isLoading} to true
			else:
				# finished loading
				set {_shotsLoaded} to min((metadata "swingAmount" of {_ply}), {_maxLoad})
	if {_autoSwing} is true:
		set metadata "autoSwing" of {_ply} to true
	set {_attrMap} to metadata "attrMap" of {_ply}
	if {_attrMap}.get("useTime") = 0:
		setPlayerStats({_ply})
		set {_attrMap} to metadata "attrMap" of {_ply}
	if {_weaponType} is not "BOW":
		{_weaponType} is not "GUN"
		play sound "item.genericSwing" with volume 1 and pitch 1 at location of {_ply}
	set {_accessory} to metadata "accessory" of {_ply}
	
	if {_isLoading} is true:
		displayLoadingProgress({_ply}, {_maxLoad})
		set {_loadSpeedMulti} to 0.5
		set {_loadSpeedMulti} to yml value "%{_itemType}%.loadTimeMulti" from file "plugins/Data/weapons.yml"
		applyCD({_ply}, ceil(({_attrMap}.get("useTime")) * ({_attrMap}.get("useTimeMulti")) * {_loadSpeedMulti}))
	else if {_weaponType} is "BOW":
		set {_map} to {_attrMap}.clone()
		set {_chanceConsumption} to {_attrMap}.get("ammoConsumptionRate")
		set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
		set {_arrow} to getAmmo({_ply}, "ARROW", {_chanceConsumption})
		if {_arrow} is set:
			set {_arrowType} to trimText(name of {_arrow})
			set {_attrMapArrow} to yml value "%{_arrowType}%.attributes" from file "plugins/Data/items.yml"
			set {_attrs} to {_attrMapArrow}.iterator()
			set {_attrMapArrow} to new HashMap()
			while {_attrs}.hasNext() is true:
				set {_info} to {_attrs}.next()
				if {_info} starts with "projectileSpeed: ":
					set {_projectileSpeed} to {_projectileSpeed} + ({_info}.split(": ")[1] parsed as number)
				else:
					set {_info::*} to {_info} split at ": "
					{_attrMapArrow}.put({_info::1}, ({_info::2} parsed as number))
					if {_info::1} is not "damageType":
						{_map}.put({_info::1}, ({_map}.getOrDefault({_info::1}, 0) + ({_info::2} parsed as number)))

			set {_penetration} to ({_attrMap}.getOrDefault("penetration", 0)) + ({_attrMapArrow}.getOrDefault("penetration", 0))
			if {_arrowType} is "木箭":
				{_accessory}.contains("熔火箭袋") is true
				set {_arrowType} to "烈焰箭"
			applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeRangedMulti")) * 0.75))
			play sound "item.bowShoot" with volume 2 and pitch 1 at location of {_ply}
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)) * ({_attrMapArrow}.getOrDefault("projectileSpeedArrowMulti", 1)))) * 0.8
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			if {_itemType} is "海啸弓":
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				set vector length of {_velocity} to {_projectileSpeed}
				set {_pOffset} to {_pitch} -25
				loop 5 times:
					set {_offSet} to new vector with yaw {_yaw} and pitch {_pOffset}
					set vector length of {_offSet} to 1.5
					add 12.5 to {_pOffset}
					set {_arrowE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation().add({_offSet}), EntityType.SNOWBALL)
					
					{_arrowE}.setCustomName({_arrowType})
					{_arrowE}.setVelocity({_velocity})
					{_arrowE}.setShooter({_ply})
					set metadata "attrMap" of {_arrowE} to {_map}
					set metadata "penetration" of {_arrowE} to {_penetration}
					set metadata "Bounce" of {_arrowE} to {_attrMapArrow}.getOrDefault("bounce", 0)
					if {_arrowType} is "狱炎箭":
						add "isGranade" to scoreboard tags of {_arrowE}
					else if {_arrowType} is "夜明箭":
						set gravity of {_arrowE} to off
					if {_projectileThruWall} is true:
						add "thruWall" to scoreboard tags of {_arrowE}
					projectileAI({_arrowE}, {_weaponType})
			else if {_itemType} is "代达罗斯风暴弓":
				if {_ply} has metadata "target":
					set {_destination} to (location of metadata "target" of {_ply}).add(0, 1, 0)
				else if targeted block of {_ply} is set:
					set {_destination} to (location of targeted block of {_ply}).add(0, 1, 0)
				else:
					set {_destination} to location of {_ply}
				if {_arrowType} is "狱炎箭":
					set {_shootAmount} to a random integer between 1 and 3
				else if {_arrowType} is "圣箭":
					set {_shootAmount} to a random integer between 2 and 5
				else:
					set {_shootAmount} to a random integer between 3 and 6
				loop {_shootAmount} times:
					set {_spawnLoc} to {_destination}.clone().add(a random number between -10 and 10, a random number between 22 and 26, a random number between -10 and 10)
					set {_velocity} to {_destination}.clone().add(0, a random number between -3 and 3, 0).subtract({_spawnLoc}).toVector()
					set {_arrowE} to (world of {_ply}).spawnEntity({_spawnLoc}, EntityType.SNOWBALL)
					set vector length of {_velocity} to {_projectileSpeed}
					{_arrowE}.setCustomName({_arrowType})
					{_arrowE}.setVelocity({_velocity})
					{_arrowE}.setShooter({_ply})
					set metadata "attrMap" of {_arrowE} to {_map}
					set metadata "penetration" of {_arrowE} to {_penetration}
					set metadata "Bounce" of {_arrowE} to {_attrMapArrow}.getOrDefault("bounce", 0)
					if {_arrowType} is "狱炎箭":
						add "isGranade" to scoreboard tags of {_arrowE}
					else if {_arrowType} is "夜明箭":
						set gravity of {_arrowE} to off
					if {_projectileThruWall} is true:
						add "thruWall" to scoreboard tags of {_arrowE}
					projectileAI({_arrowE}, {_weaponType})
			else:
				set {_shots} to 1
				set {_shots} to yml value "%{_itemType}%.shots" from file "plugins/Data/weapons.yml"
				set {_offSet} to yml value "%{_itemType}%.offSet" from file "plugins/Data/weapons.yml"
				loop {_shots} times:
					set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
					if {_offSet} is set:
						set vector length of {_velocity} to {_offSet}
						{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
					set {_arrowE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SNOWBALL)
					
					set vector length of {_velocity} to {_projectileSpeed}
					if {_itemType} is "幻象弓":
						set vector length of {_velocity} to ({_projectileSpeed} * a random number between 0.5 and 1.5)
					{_arrowE}.setCustomName({_arrowType})
					{_arrowE}.setVelocity({_velocity})
					{_arrowE}.setShooter({_ply})
					set metadata "attrMap" of {_arrowE} to {_map}
					set metadata "penetration" of {_arrowE} to {_penetration}
					set metadata "Bounce" of {_arrowE} to {_attrMapArrow}.getOrDefault("bounce", 0)
					projectileAI({_arrowE}, {_weaponType})
					if {_arrowType} is "狱炎箭":
						add "isGranade" to scoreboard tags of {_arrowE}
					else if {_arrowType} is "夜明箭":
						set gravity of {_arrowE} to off
					if {_projectileThruWall} is true:
						add "thruWall" to scoreboard tags of {_arrowE}
					if {_itemType} is "幻象弓":
						add "isVortex" to scoreboard tags of {_arrowE}
					else if {_itemType} is "日暮":
						if gamemode of {_ply} is spectator:
							stop trigger
						play sound "item.bowShoot" with volume 2 and pitch 1 at location of {_ply}
						set {_yaw} to {_ply}.getHandle().yaw
						set {_pitch} to {_ply}.getHandle().pitch
						wait 1 tick
		else:
			set metadata "autoSwing" of {_ply} to false
	else if {_weaponType} is "GUN":
		set {_map} to {_attrMap}.clone()
		set {_chanceConsumption} to {_attrMap}.get("ammoConsumptionRate")
		set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
		set {_bltInv} to (metadata "inventories" of {_ply}).get("voidBag")
		set {_bltInd} to {_bltInv}.first(Material.SLIME_BALL)
		if {_bltInd} < 0:
			set {_bltInv} to {_ply}'s inventory
			set {_bltInd} to {_bltInv}.first(Material.SLIME_BALL)
		if {_bltInd} >= 0:
			set {_bullet} to 1 of slot {_bltInd} of {_bltInv}
			set {_attrMapBullet} to yml value "%trimText(name of {_bullet})%.attributes" from file "plugins/Data/items.yml"
			set {_attrs} to {_attrMapBullet}.iterator()
			set {_attrMapBullet} to new HashMap()
			while {_attrs}.hasNext() is true:
				set {_info} to {_attrs}.next()
				if {_info} starts with "ammoConsumptionRate: ":
					set {_chanceConsumption} to {_chanceConsumption} * ({_info}.split(": ")[1] parsed as number)
				else if {_info} starts with "projectileSpeed: ":
					set {_projectileSpeed} to {_projectileSpeed} + ({_info}.split(": ")[1] parsed as number)
				else:
					set {_info::*} to {_info} split at ": "
					{_attrMapBullet}.put({_info::1}, ({_info::2} parsed as number))
					if {_info::1} is not "damageType":
						{_map}.put({_info::1}, ({_map}.getOrDefault({_info::1}, 0) + ({_info::2} parsed as number)))
			if chance of {_chanceConsumption}:
				remove {_bullet} from slot {_bltInd} of {_bltInv}
		if {_bullet} is set:
			set {_shots} to 1
			set {_shots} to yml value "%{_itemType}%.shots" from file "plugins/Data/weapons.yml"
			if {_autoSwing} is true:
				play sound "item.gunfire" with volume 3 and pitch 1 at location of {_ply}
			else:
				play sound "entity.generic.explode" with volume 3 and pitch 1.2 at location of {_ply}
			applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeRangedMulti")) * 0.75))
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)) * ({_attrMapBullet}.getOrDefault("projectileSpeedBulletMultiMulti", 1)))) * 0.8
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_offSet} to yml value "%{_itemType}%.offSet" from file "plugins/Data/weapons.yml"
			loop {_shots} times:
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				if {_offSet} is set:
					set vector length of {_velocity} to {_offSet}
					{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
				set {_bulletE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
				
				set vector length of {_velocity} to {_projectileSpeed}
				{_bulletE}.setCustomName(trimText(name of {_bullet}))
				set metadata "attrMap" of {_bulletE} to {_map}
				{_bulletE}.setVelocity({_velocity})
				{_bulletE}.setShooter({_ply})
				set gravity of {_bulletE} to off
				
				set {_list} to new ArrayList()
				{_list}.add({_ply})
				set metadata "collided" of {_bulletE} to {_list}
				set metadata "penetration" of {_bulletE} to {_attrMapBullet}.getOrDefault("penetration", 0)
				set metadata "Bounce" of {_bulletE} to {_attrMapBullet}.getOrDefault("bounce", 0)
				if trimText(name of {_bullet}) is "爆炸弹":
					add "isGranade" to scoreboard tags of {_bulletE}
				if {_projectileThruWall} is true:
					add "thruWall" to scoreboard tags of {_bulletE}
				projectileAI({_bulletE}, {_weaponType})
				if {_itemType} is "发条突击步枪":
					play sound "item.gunfire" with volume 3 and pitch 1.2 at location of {_ply}
					wait 1 tick
					if gamemode of {_ply} is spectator:
						stop trigger
					set {_yaw} to {_ply}.getHandle().yaw
					set {_pitch} to {_ply}.getHandle().pitch
			if {_itemType} is "玛瑙爆破枪":
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				set {_bulletE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
				
				set vector length of {_velocity} to {_projectileSpeed} * 0.8
				{_bulletE}.setCustomName("玛瑙能量")
				set metadata "attrMap" of {_bulletE} to {_map}
				{_bulletE}.setVelocity({_velocity})
				{_bulletE}.setShooter({_ply})
				set gravity of {_bulletE} to off
				
				set {_list} to new ArrayList()
				{_list}.add({_ply})
				set metadata "collided" of {_bulletE} to {_list}
				set metadata "penetration" of {_bulletE} to 0
				set metadata "Bounce" of {_bulletE} to 0
				add "isGranade" to scoreboard tags of {_bulletE}
				projectileAI({_bulletE}, {_weaponType})
			else if {_itemType} is "星璇机枪":
				mod(metadata "swingAmount" of {_ply}, 5) = 4
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				set vector length of {_velocity} to 22
				{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
				set {_bulletE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
				
				set vector length of {_velocity} to {_projectileSpeed}
				{_bulletE}.setCustomName("星璇导弹")
				set {_map} to {_map}.clone()
				{_map}.put("damage", 140)
				set metadata "attrMap" of {_bulletE} to {_map}
				{_bulletE}.setVelocity({_velocity})
				{_bulletE}.setShooter({_ply})
				set gravity of {_bulletE} to off
				
				set {_list} to new ArrayList()
				{_list}.add({_ply})
				set metadata "collided" of {_bulletE} to {_list}
				set metadata "penetration" of {_bulletE} to 0
				set metadata "Bounce" of {_bulletE} to 0
				add "isGranade" to scoreboard tags of {_bulletE}
				projectileAI({_bulletE}, {_weaponType})
		else:
			set metadata "autoSwing" of {_ply} to false
	else if {_weaponType} is "STAB" or "SWING":
		set {_yaw} to {_ply}.getHandle().yaw
		set {_pitch} to {_ply}.getHandle().pitch
		set {_v} to new vector with yaw {_yaw} and pitch {_pitch}
		set {_size} to yml value "%{_itemType}%.size" from file "plugins/Data/weapons.yml"
		set {_size} to {_size} * ({_attrMap}.getOrDefault("meleeReachMulti", 1))
		set vector length of {_v} to max({_size}, 0)
		set {_color} to yml value "%{_itemType}%.particleColor" from file "plugins/Data/weapons.yml"
		set {_projectileInfo} to yml value "%{_itemType}%.projectileInfo" from file "plugins/Data/weapons.yml"
		set {_useTimeMulti} to ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeMeleeMulti"))
		if {_projectileInfo} is set:
			set {_attrMapProjectile} to {_attrMap}.clone()
			set {_shootInterval} to (({_projectileInfo}.get("interval")) - 0.01) / {_useTimeMulti}
			set {_canShoot} to false
			set {_modulo} to mod((metadata "swingAmount" of {_ply}), ceil({_shootInterval}))
			if {_modulo} = 0:
				set {_canShoot} to true
			else:
				set {_chance} to {_shootInterval} - {_modulo}
				if {_chance} < 1:
					chance of (1 - {_chance})
					set {_canShoot} to true
			if {_canShoot} is true:
				set {_vProjectile} to new vector with yaw {_yaw} and pitch {_pitch}
				set vector length of {_vProjectile} to {_projectileInfo}.get("velocity")
				if {_weaponType} is "STAB":
					set {_swordProjectile} to spawnProjectile({_ply}, {_vProjectile}, {_attrMapProjectile}, {_projectileInfo}.get("name"), ((eye location of {_ply}).add({_v})))
				else:
					set {_swordProjectile} to mobProjectile({_ply}, {_vProjectile}, {_attrMapProjectile}, {_projectileInfo}.get("name"))
				
				if {_projectileInfo}.get("noGravity") is true:
					set gravity of {_swordProjectile} to off
				if {_projectileInfo}.get("isGranade") is true:
					add "isGranade" to scoreboard tags of {_swordProjectile}
				if {_projectileInfo}.get("damageMulti") is set:
					{_attrMapProjectile}.put("damage", ({_attrMapProjectile}.get("damage")) * ({_projectileInfo}.get("damageMulti")))
				if {_projectileInfo}.get("penetration") is set:
					set metadata "penetration" of {_swordProjectile} to {_projectileInfo}.get("penetration")
				if {_projectileInfo}.get("bounce") is set:
					set metadata "Bounce" of {_swordProjectile} to {_projectileInfo}.get("bounce")
				set metadata "damageSourcePlayer" of {_swordProjectile} to {_ply}
				if {_projectileThruWall} is true:
					add "thruWall" to scoreboard tags of {_swordProjectile}
				projectileAI({_swordProjectile}, "ARROW")
		if {_weaponType} is "SWING":
			set {_toDamage} to new ArrayList()
			set {_dirFixed} to yml value "%{_itemType}%.dirFixed" from file "plugins/Data/weapons.yml"
			set {_timeTotal} to ceil({_attrMap}.get("useTime") * {_useTimeMulti})
			applyCD({_ply}, {_timeTotal})
			if {_itemType} is "天顶剑":
				set {_loopTime} to max(floor({_timeTotal} / 5), 1)
				loop {_loopTime} times:
					set {_colorIndex} to a random integer between 0 and 5
					set {_destination} to (eye location of {_ply}).add({_v})
					if metadata "target" of {_ply} is set:
						set {_target} to metadata "target" of {_ply}
						set {_destination} to eye location of {_target}
						wait 1 tick
						set {_newLoc} to eye location of {_target}
						set {_dV} to {_newLoc}.subtract({_destination}).toVector()
						if vector length of {_dV} > 0:
							set vector length of {_dV} to (vector length of {_dV}) * 8
							set {_destination} to (eye location of {_target}).add({_dV})
					else:
						set {_target} to {_ply}
						if targeted block of {_ply} is set:
							set {_destination} to (location of targeted block of {_ply}).add(0, 1, 0)
						wait 1 tick
					handleZenith({_ply}, {_color}.get({_colorIndex}), {_destination}, {_item}, {_target})
					wait 4 ticks
					if gamemode of {_ply} is spectator:
						stop trigger
			else:
				set {_loopTime} to 20
				set {_lastWait} to 0
				if {_itemType} is "狂星之怒":
					if {_ply} has metadata "target":
						set {_destination} to (location of metadata "target" of {_ply}).add(0, 1, 0)
					else if targeted block of {_ply} is set:
						set {_destination} to (location of targeted block of {_ply}).add(0, 1, 0)
					else:
						set {_destination} to location of {_ply}
					set {_attrMapStar} to {_attrMap}.clone()
					{_attrMapStar}.put("damage", 440)
					loop 3 times:
						set {_spawnLoc} to {_destination}.clone().add(a random number between -8 and 8, 26, a random number between -8 and 8)
						set {_velocity} to {_destination}.clone().subtract({_spawnLoc}).toVector()
						set vector length of {_velocity} to 2
						set {_projectile} to spawnProjectile({_ply}, {_velocity}, {_attrMapStar}, "狂星之怒", {_spawnLoc})
						set gravity of {_projectile} to off
						add "thruWall" to scoreboard tags of {_projectile}
						projectileAI({_projectile}, "MAGIC")
				loop {_loopTime} times:
					if gamemode of {_ply} is spectator:
						stop trigger
					if {_dirFixed} is set:
						{_dirFixed} is false
						set {_yaw} to {_ply}.getHandle().yaw
					handleStrikeLine({_ply}, {_yaw}, ((170 * loop-number / {_loopTime}) - 110), {_size}, {_item}, {_color}, {_toDamage}, false, {_null})
					set {_currWait} to floor(loop-number / {_loopTime} * {_timeTotal})
					if {_currWait} > {_lastWait}:
						wait "%{_currWait} - {_lastWait}% ticks" parsed as timespan
						set {_lastWait} to {_currWait}
		else:
			set {_useTime} to ceil({_attrMap}.get("useTime") * {_useTimeMulti})
			applyCD({_ply}, {_useTime})
			if {_itemType} is "星光":
				set {_c} to new ArrayList(1)
				set {_loopTime} to floor({_useTime} / 2)
				if mod({_useTime}, 2) = 0:
					remove 1 from {_loopTime}
				loop {_loopTime} times:
					if gamemode of {_ply} is spectator:
						stop trigger
					set vector length of {_v} to 10
					{_v}.add(vector((a random number between -1.5 and 1.5), (a random number between -1.5 and 1.5), (a random number between -1.5 and 1.5)))
					{_c}.add({_color}.get(a random integer between 0 and ({_color}.size() - 1)))
					handleStrikeLine({_ply}, (vector yaw of {_v}), (vector pitch of {_v}), {_size}, {_item}, {_c}, new ArrayList(), true, {_null})
					play sound "item.genericSwing" with volume 1 and pitch 1 at location of {_ply}
					wait 2 ticks
					{_c}.clear()
			else:
				handleStrikeLine({_ply}, {_ply}.getHandle().yaw, {_ply}.getHandle().pitch, {_size}, {_item}, {_color}, new ArrayList(), false, {_null})
	else if {_weaponType} is "WHIP":
		set {_toDamage} to new ArrayList()
		set {_size} to yml value "%{_itemType}%.size" from file "plugins/Data/weapons.yml"
		set {_size} to {_size} * ({_attrMap}.getOrDefault("meleeReachMulti", 1))
		set {_timeTotal} to ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeMeleeMulti")))
		applyCD({_ply}, {_timeTotal})
		set {_color} to yml value "%{_itemType}%.particleColor" from file "plugins/Data/weapons.yml"
		if {_itemType} is "日耀喷发剑":
			set {_dYaw} to a random number between -180 and 180
			set {_dPitch} to a random number between -100 and 100
			set {_thruWall} to true
		else:
			set {_dYaw} to a random number between -45 and 45
			set {_dPitch} to 60
			set {_thruWall} to false
		set {_yaw} to "%{_ply}.getHandle().yaw%" parsed as number
		set {_pitch} to "%{_ply}.getHandle().pitch%" parsed as number
		remove ({_dYaw} / 2) from {_yaw}
		remove ({_dPitch} / 2) from {_pitch}
		set {_loopTime} to 25
		set {_decay} to yml value "%{_itemType}%.decay" from file "plugins/Data/weapons.yml"
		set {_whipBonus} to yml value "%{_itemType}%.bonusDamage" from file "plugins/Data/weapons.yml"
		set {_inflictBuff} to yml value "%{_itemType}%.inflictsBuff" from file "plugins/Data/weapons.yml"
		if {_whipBonus} is set:
			set {_infoMap} to new HashMap(6)
			{_infoMap}.put("decay", {_decay})
			{_infoMap}.put("whipBonus", {_whipBonus})
			{_infoMap}.put("inflictBuff", {_inflictBuff})
		set {_halfTime} to {_loopTime} / 2
		set {_lastWait} to 0
		loop {_loopTime} times:
			if gamemode of {_ply} is spectator:
				stop trigger
			set {_currentYaw} to {_yaw} + {_dYaw} * (loop-number / {_loopTime})
			set {_currentPitch} to {_pitch} + {_dPitch} * (loop-number / {_loopTime})
			if loop-number <= {_halfTime}:
				set {_sizeMulti} to 1 - (min({_halfTime} + 2 - (loop-number), {_halfTime}) / {_halfTime})
			else:
				set {_sizeMulti} to 1 - (min((loop-number) + 3 - {_halfTime}, {_halfTime}) / {_halfTime})
			if {_infoMap} is set:
				set {_damage} to handleStrikeLine({_ply}, {_currentYaw}, {_currentPitch}, ({_size} * {_sizeMulti}), {_item}, {_color}, {_toDamage}, {_thruWall}, {_infoMap})
				{_infoMap}.put("damage", {_damage})
			else:
				handleStrikeLine({_ply}, {_currentYaw}, {_currentPitch}, ({_size} * {_sizeMulti}), {_item}, {_color}, {_toDamage}, {_thruWall}, {_infoMap})
			set {_currWait} to floor(loop-number / {_loopTime} * {_timeTotal})
			if {_currWait} > {_lastWait}:
				wait "%{_currWait} - {_lastWait}% ticks" parsed as timespan
				set {_lastWait} to {_currWait}
	else if {_weaponType} is "BOOMERANG":
		shootBoomerang({_ply}, {_itemType}, {_item})
	else if {_weaponType} is "YOYO":
		shootYoyo({_ply}, {_itemType}, {_item})
	else if {_weaponType} starts with "THROW":
		applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeRangedMulti"))))
		set {_map} to {_attrMap}.clone()
		set {_throwItem} to {_ply}'s tool
		if {_weaponType} is "THROW_PROJECTILE":
			if chance of ({_attrMap}.getOrDefault("ammoConsumptionRate", 1)):
				remove 1 of {_throwItem} from {_ply}'s tool
			set {_attrMapItem} to yml value "%trimText(name of {_throwItem})%.attributes" from file "plugins/Data/items.yml"
			set {_attrs} to {_attrMapItem}.iterator()
			set {_attrMapItem} to new HashMap()
			while {_attrs}.hasNext() is true:
				set {_info} to {_attrs}.next()
				set {_info::*} to {_info} split at ": "
				{_attrMapItem}.put({_info::1}, ({_info::2} parsed as number))
			
			set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)))) * 0.65
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
			set {_throwItemE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
			set vector length of {_velocity} to {_projectileSpeed}
			{_throwItemE}.setCustomName(trimText(name of {_throwItem}))
			set metadata "attrMap" of {_throwItemE} to {_map}
			{_throwItemE}.setVelocity({_velocity})
			{_throwItemE}.setShooter({_ply})
			set {_list} to new ArrayList()
			{_list}.add({_ply})
			set metadata "collided" of {_throwItemE} to {_list}
			set metadata "penetration" of {_throwItemE} to {_attrMapItem}.getOrDefault("penetration", 0)
			set metadata "Bounce" of {_throwItemE} to {_attrMapItem}.getOrDefault("bounce", 0)
			if {_projectileThruWall} is true:
				add "thruWall" to scoreboard tags of {_throwItemE}
			projectileAI({_throwItemE}, {_weaponType})
		else if {_weaponType} is "THROW_GRENADE":
			remove 1 of {_throwItem} from {_ply}'s tool
			if {_itemType} is "炸弹" or "粘性炸弹" or "雷管" or "粘性雷管":
				{_map}.put("crit", 0)
				{_map}.put("damageMulti", 1)
				{_map}.put("damageArrowMulti", 1)
				{_map}.put("damageRangedMulti", 1)
			set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)))) * 0.45
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
			set {_throwItemE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
			set vector length of {_velocity} to {_projectileSpeed}
			{_throwItemE}.setCustomName(trimText(name of {_throwItem}))
			set metadata "attrMap" of {_throwItemE} to {_map}
			{_throwItemE}.setVelocity({_velocity})
			{_throwItemE}.setShooter({_ply})
			set {_list} to new ArrayList()
			{_list}.add({_ply})
			set metadata "collided" of {_throwItemE} to {_list}
			set metadata "Bounce" of {_throwItemE} to 4
			add "isGranade" to scoreboard tags of {_throwItemE}
			projectileAI({_throwItemE}, {_weaponType})
		if item amount of {_throwItem} is 1:
			handlePlayerSwitchItem({_ply}, {_throwItem}, air)
	else if {_weaponType} starts with "MAGIC":
		set {_manaCost} to round(({_attrMap}.get("manaUse")) * ({_attrMap}.getOrDefault("manaUseMulti", 1)))
		if {_itemType} is "太空枪":
			metadata "armorSet" of {_ply} is "流星套装"
			set {_manaCost} to 0
		if {_itemType} is "终极棱镜":
			set {_swingAmount} to metadata "swingAmount" of {_ply}
			set {_manaCost} to {_manaCost} * sqrt({_swingAmount} + 4) / 3
		if level of {_ply} < {_manaCost}:
			loop ...{_accessory}:
				if loop-value is "魔力花" or "磁花":
					loop 36 times:
						set {_potion} to 1 of (slot ((loop-number) - 1) of {_ply}'s inventory)
						set {_namePotion} to trimText(name of {_potion})
						{_namePotion} ends with "魔力药水"
						set {_nodes::*} to yml nodes "%{_namePotion}%" from file "plugins/Data/consumeable.yml"
						{_nodes::*} is set
						loop {_nodes::*}:
							loop-value-3 is "mana"
							set {_manaRecovery} to yml value "%{_namePotion}%.%loop-value-3%" from file "plugins/Data/consumeable.yml"
						if {_manaRecovery} is set:
							set level of {_ply} to min(({_attrMap}.get("maxMana")), (level of {_ply} + {_manaRecovery}))
							displayHolo({_ply}, {_manaRecovery}, false, "回蓝")
							play sound "entity.generic.drink" with volume 1 and pitch 1 at location of {_ply}
							applyEffect({_ply}, "魔力疾病", 200)
						remove {_potion} from {_ply}'s inventory
						stop loop
					stop loop
			level of {_ply} < {_manaCost}
			set metadata "autoSwing" of {_ply} to false
			stop trigger
		set level of {_ply} to level of {_ply} - {_manaCost}
		set {_attrMapStaff} to yml value "%{_itemType}%.attributes" from file "plugins/Data/items.yml"
		set {_attrs} to {_attrMapStaff}.iterator()
		set {_attrMapStaff} to new HashMap()
		while {_attrs}.hasNext() is true:
			set {_info} to {_attrs}.next()
			set {_info::*} to {_info} split at ": "
			{_attrMapStaff}.put({_info::1}, ({_info::2} parsed as number))
		set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
		set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)))) * 0.42
		applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeMagicMulti"))))
		set {_map} to {_attrMap}.clone()
		if {_weaponType} is "MAGIC_PROJECTILE":
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_pName} to "法球"
			set {_pName} to yml value "%{_itemType}%.projectileName" from file "plugins/Data/weapons.yml"
			set {_offSet} to yml value "%{_itemType}%.offSet" from file "plugins/Data/weapons.yml"
			set {_hasGravity} to yml value "%{_itemType}%.gravity" from file "plugins/Data/weapons.yml"
			set {_shootAmount} to 1
			if {_itemType} is "夜光":
				set {_shootAmount} to 6
			else if {_itemType} is "蝙蝠权杖":
				set {_shootAmount} to a random integer between 1 and 3
			else if {_itemType} is "剃刀松":
				set {_shootAmount} to a random integer between 2 and 4
			else if {_itemType} is "泡泡枪":
				set {_shootAmount} to 3
			else if {_itemType} is "利刃台风":
				set {_shootAmount} to 2
			else if {_itemType} is "星云烈焰":
				chance of 0.2
				set {_pName} to "星云烈焰炮弹"
				{_map}.put("damageMulti", ({_map}.get("damageMulti")) + 2)
				set {_projectileSpeed} to {_projectileSpeed} * 1.25
			loop {_shootAmount} times:
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				if {_offSet} is set:
					set vector length of {_velocity} to {_offSet}
					{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
				set vector length of {_velocity} to {_projectileSpeed}
				set {_magicProjectile} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
				{_magicProjectile}.setCustomName({_pName})
				set metadata "attrMap" of {_magicProjectile} to {_map}
				{_magicProjectile}.setVelocity({_velocity})
				{_magicProjectile}.setShooter({_ply})
				set {_list} to new ArrayList()
				{_list}.add({_ply})
				set metadata "collided" of {_magicProjectile} to {_list}
				set metadata "penetration" of {_magicProjectile} to {_attrMapStaff}.getOrDefault("penetration", 0)
				set metadata "Bounce" of {_magicProjectile} to {_attrMapStaff}.getOrDefault("bounce", 0)
				if {_hasGravity} is false:
					set gravity of {_magicProjectile} to off
				if {_itemType} is "星云奥秘" or "狱火叉":
					add "isGranade" to scoreboard tags of {_magicProjectile}
				if {_projectileThruWall} is true:
					add "thruWall" to scoreboard tags of {_magicProjectile}
				projectileAI({_magicProjectile}, {_weaponType})
				if {_itemType} is "利刃台风":
					wait 10 ticks
					set {_yaw} to {_ply}.getHandle().yaw
					set {_pitch} to {_ply}.getHandle().pitch
		else:
			if {_itemType} is "月之耀斑" or "暴雪法杖" or "裂天剑":
				if {_ply} has metadata "target":
					set {_target} to metadata "target" of {_ply}
					set {_destination} to eye location of {_target}
				else if targeted block of {_ply} is set:
					set {_destination} to (location of targeted block of {_ply}).add(0, 1, 0)
				else:
					set {_destination} to location of {_ply}
				if {_itemType} is "月之耀斑":
					set {_loopTime} to 3
				else if {_itemType} is "暴雪法杖":
					set {_loopTime} to a random integer between 10 and 25
				else:
					set {_loopTime} to a random integer between 2 and 4
				loop {_loopTime} times:
					if {_itemType} is "月之耀斑":
						set {_spawnLoc} to {_destination}.clone().add(a random number between -8 and 8, 26, a random number between -8 and 8)
						set {_velocity} to {_destination}.clone().subtract({_spawnLoc}).toVector()
					else if {_itemType} is "暴雪法杖":
						set {_spawnLoc} to {_destination}.clone().add(a random number between -8 and 8, 26, a random number between -8 and 8)
						set {_velocity} to {_destination}.clone().add((a random number between -5 and 5), (a random number between -5 and 5), (a random number between -5 and 5)).subtract({_spawnLoc}).toVector()
					else:
						set {_spawnLoc} to (eye location of {_ply}).add(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1)
						set {_velocity} to {_destination}.clone().subtract({_spawnLoc}).toVector()
					set {_magicProjectile} to (world of {_ply}).spawnEntity({_spawnLoc}, EntityType.SPLASH_POTION)
					set vector length of {_velocity} to {_projectileSpeed}
					set {_pName} to yml value "%{_itemType}%.projectileName" from file "plugins/Data/weapons.yml"
					{_magicProjectile}.setCustomName({_pName})
					set metadata "attrMap" of {_magicProjectile} to {_map}
					{_magicProjectile}.setVelocity({_velocity})
					{_magicProjectile}.setShooter({_ply})
					set {_list} to new ArrayList()
					{_list}.add({_ply})
					set metadata "collided" of {_magicProjectile} to {_list}
					set gravity of {_magicProjectile} to off
					if {_itemType} is "月之耀斑":
						add "isGranade" to scoreboard tags of {_magicProjectile}
						add "thruWall" to scoreboard tags of {_magicProjectile}
						set metadata "thruWallHeight" of {_magicProjectile} to y-coordinate of {_destination}
					if {_projectileThruWall} is true:
						add "thruWall" to scoreboard tags of {_magicProjectile}
					projectileAI({_magicProjectile}, {_weaponType})
					wait 3 ticks
			else if {_itemType} is "爆裂藤蔓":
				set {_length} to 0
				set {_extra} to new HashMap(2)
				{_extra}.put("startLocation", eye location of {_ply})
				set {_color} to new ArrayList(1)
				{_color}.add("103|78|50")
				set {_yaw} to {_ply}.getHandle().yaw
				set {_pitch} to {_ply}.getHandle().pitch
				loop 6 times:
					add 2 to {_length}
					handleStrikeLine({_ply}, {_yaw}, {_pitch}, {_length}, {_item}, {_color}, new ArrayList(), true, {_extra})
					wait 4 ticks
			else if {_itemType} is "暗影束法杖":
				set {_color} to new ArrayList(1)
				{_color}.add("255|125|255")
				set {_yaw} to {_ply}.getHandle().yaw
				set {_pitch} to {_ply}.getHandle().pitch
				set {_extra} to new HashMap(3)
				{_extra}.put("decay", 0.1)
				{_extra}.put("bounceWhenHitBlock", true)
				handleStrikeLine({_ply}, {_yaw}, {_pitch}, 48, {_item}, {_color}, new ArrayList(), false, {_extra})
			else if {_itemType} is "高温射线枪":
				set {_color} to new ArrayList(1)
				{_color}.add("255|225|0")
				set {_yaw} to {_ply}.getHandle().yaw
				set {_pitch} to {_ply}.getHandle().pitch
				handleStrikeLine({_ply}, {_yaw}, {_pitch}, 40, {_item}, {_color}, new ArrayList(), false, {_null})
			else if {_itemType} is "终极棱镜":
				set {_color1} to new ArrayList(1)
				{_color1}.add("255|0|0")
				set {_color2} to new ArrayList(1)
				{_color2}.add("255|165|0")
				set {_color3} to new ArrayList(1)
				{_color3}.add("255|255|0")
				set {_color4} to new ArrayList(1)
				{_color4}.add("0|128|0")
				set {_color5} to new ArrayList(1)
				{_color5}.add("0|0|255")
				set {_color6} to new ArrayList(1)
				{_color6}.add("75|0|130")
				set {_color7} to new ArrayList(1)
				{_color7}.add("238|130|238")
				set {_yaw} to {_ply}.getHandle().yaw
				set {_pitch} to {_ply}.getHandle().pitch
				set {_delta} to max((25 - {_swingAmount}), 1)
				set {_offSet} to {_swingAmount} * {_swingAmount} * 3
				set {_rotationIndex} to 0
				loop 7 times:
					if (mod({_swingAmount}, 7) + 1) = loop-number:
						set {_yawNew} to {_yaw}
						set {_pitchNew} to {_pitch}
					else:
						add 1 to {_rotationIndex}
						set {_yawNew} to {_yaw} + (sin(({_rotationIndex} * 60) + {_offSet}) * {_delta})
						set {_pitchNew} to {_pitch} + (cos(({_rotationIndex} * 60) + {_offSet}) * {_delta})
					handleStrikeLine({_ply}, {_yawNew}, {_pitchNew}, (100 - ({_delta} * 1.5)), {_item}, {_color%loop-number%}, new ArrayList(), false, {_null})
	else if {_weaponType} is "SPECIAL_AMMO":
		set {_map} to {_attrMap}.clone()
		set {_chanceConsumption} to {_attrMap}.get("ammoConsumptionRate")
		set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
		set {_ammoName} to yml value "%{_itemType}%.ammo" from file "plugins/Data/weapons.yml"
		if {_ammoName} is set:
			if {_ammoName} starts with "_":
				set {_ammo} to air
				set {_ammoName} to subtext of {_ammoName} from characters 2 to the length of {_ammoName}
			else:
				set {_ammoInv} to (metadata "inventories" of {_ply}).get("voidBag")
				set {_ammoInd} to 0
				loop 27 times:
					set {_ammo} to 1 of slot {_ammoInd} of {_ammoInv}
					if trimText(name of {_ammo}) is {_ammoName}:
						if chance of {_chanceConsumption}:
							remove {_ammo} from slot {_ammoInd} of {_ammoInv}
						stop loop
					clear {_ammo}
					add 1 to {_ammoInd}
				if {_ammo} is not set:
					set {_ammoInv} to {_ply}'s inventory
					set {_ammoInd} to 0
					loop 36 times:
						set {_ammo} to 1 of slot {_ammoInd} of {_ammoInv}
						if trimText(name of {_ammo}) is {_ammoName}:
							if chance of {_chanceConsumption}:
								remove {_ammo} from slot {_ammoInd} of {_ammoInv}
							stop loop
						clear {_ammo}
						add 1 to {_ammoInd}
		
		if {_ammo} is set:
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)))) * 0.5
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_shots} to 1
			set {_shots} to yml value "%{_itemType}%.shots" from file "plugins/Data/weapons.yml"
			set {_offSet} to yml value "%{_itemType}%.offSet" from file "plugins/Data/weapons.yml"
			set {_displayName} to {_ammoName}
			set {_cd} to ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeRangedMulti")))
			if {_itemType} is "精灵熔枪":
				set {_displayName} to "火焰"
				set {_shots} to floor({_cd} / 2) - 1
			else if {_maxLoad} is set:
				set {_shots} to {_shotsLoaded}
			applyCD({_ply}, {_cd})
			loop {_shots} times:
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				if {_offSet} is set:
					set vector length of {_velocity} to {_offSet}
					{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
				set {_arrowE} to (world of {_ply}).spawnEntity({_ply}.getEyeLocation(), EntityType.SPLASH_POTION)
				
				set vector length of {_velocity} to {_projectileSpeed}
				set {_hasGravity} to yml value "%{_itemType}%.gravity" from file "plugins/Data/weapons.yml"
				if {_hasGravity} is false:
					set gravity of {_arrowE} to off
				set {_isGranade} to yml value "%{_itemType}%.isGranade" from file "plugins/Data/weapons.yml"
				if {_isGranade} is true:
					add "isGranade" to scoreboard tags of {_arrowE}
				{_arrowE}.setCustomName({_displayName})
				{_arrowE}.setVelocity({_velocity})
				{_arrowE}.setShooter({_ply})
				set metadata "attrMap" of {_arrowE} to {_map}
				set metadata "penetration" of {_arrowE} to {_attrMap}.getOrDefault("penetration", 0)
				set metadata "Bounce" of {_arrowE} to {_attrMap}.getOrDefault("bounce", 0)
				if {_projectileThruWall} is true:
					add "thruWall" to scoreboard tags of {_arrowE}
				projectileAI({_arrowE}, {_weaponType})
				if {_itemType} is "精灵熔枪":
					wait 2 ticks
					if gamemode of {_ply} is spectator:
						stop trigger
					set {_yaw} to {_ply}.getHandle().yaw
					set {_pitch} to {_ply}.getHandle().pitch
		else:
			set metadata "autoSwing" of {_ply} to false
	else if {_weaponType} is "SUMMON" or "SENTRY":
		set {_manaCost} to round(({_attrMap}.get("manaUse")) * ({_attrMap}.getOrDefault("manaUseMulti", 1)))
		if level of {_ply} < {_manaCost}:
			set metadata "autoSwing" of {_ply} to false
			stop trigger
		set {_minionSlot} to 1
		set {_minionSlot} to yml value "%{_itemType}%.minionSlot" from file "plugins/Data/weapons.yml"
		if {_minionSlot} > ({_attrMap}.get("minionLimit")):
			set metadata "autoSwing" of {_ply} to false
			stop trigger
		set level of {_ply} to level of {_ply} - {_manaCost}
		set {_nameMinion} to yml value "%{_itemType}%.minionName" from file "plugins/Data/weapons.yml"
		set {_attrMapMinion} to {_attrMap}.clone()
		if {_nameMinion} is "矮人":
			set {_minion} to (world of {_ply}).spawnEntity((location of {_ply}), EntityType.HUSK)
			{_minion}.setBaby(true)
		else if {_nameMinion} is "蜘蛛":
			set {_minion} to (world of {_ply}).spawnEntity((location of {_ply}), EntityType.CAVE_SPIDER)
		else:
			set {_minion} to (world of {_ply}).spawnEntity((location of {_ply}), EntityType.SLIME)
			slimeResize({_minion}, 1)
		{_attrMapMinion}.put("damageType", yml value "%{_itemType}%.damageType" from file "plugins/Data/weapons.yml")
		set metadata "attrMap" of {_minion} to {_attrMapMinion}
		if {_weaponType} is "SUMMON":
			minionAI({_minion}, {_ply}, {_nameMinion}, {_minionSlot})
		else:
			sentryAI({_minion}, {_ply}, {_nameMinion})
		set max health of {_minion} to 222
		set health of {_minion} to 222
		applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti"))))
	else if {_weaponType} is "ROCKET":
		set {_map} to {_attrMap}.clone()
		set {_chanceConsumption} to {_attrMap}.get("ammoConsumptionRate")
		set {_projectileSpeed} to {_attrMap}.get("projectileSpeed")
		set {_rocketInv} to (metadata "inventories" of {_ply}).get("voidBag")
		set {_rocketInd} to {_rocketInv}.first(Material.BLAZE_POWDER)
		if {_rocketInd} < 0:
			set {_rocketInv} to {_ply}'s inventory
			set {_rocketInd} to {_rocketInv}.first(Material.BLAZE_POWDER)
		if {_rocketInd} >= 0:
			set {_rocket} to 1 of slot {_rocketInd} of {_rocketInv}
			set {_attrMapRocket} to yml value "%trimText(name of {_rocket})%.attributes" from file "plugins/Data/items.yml"
			set {_attrs} to {_attrMapRocket}.iterator()
			set {_attrMapRocket} to new HashMap()
			while {_attrs}.hasNext() is true:
				set {_info} to {_attrs}.next()
				if {_info} starts with "ammoConsumptionRate: ":
					set {_chanceConsumption} to {_chanceConsumption} * ({_info}.split(": ")[1] parsed as number)
				else if {_info} starts with "projectileSpeed: ":
					set {_projectileSpeed} to {_projectileSpeed} + ({_info}.split(": ")[1] parsed as number)
				else:
					set {_info::*} to {_info} split at ": "
					{_attrMapRocket}.put({_info::1}, ({_info::2} parsed as number))
					if {_info::1} is not "damageType":
						{_map}.put({_info::1}, ({_map}.getOrDefault({_info::1}, 0) + ({_info::2} parsed as number)))
			if chance of {_chanceConsumption}:
				remove {_rocket} from slot {_rocketInd} of {_rocketInv}
		if {_rocket} is set:
			play sound "item.bowShoot" with volume 3 and pitch 1 at location of {_ply}
			set {_projectileSpeed} to sqrt(abs({_projectileSpeed} * ({_attrMap}.getOrDefault("projectileSpeedMulti", 1)) * ({_attrMapRocket}.getOrDefault("projectileSpeedArrowMulti", 1)))) * 0.8
			set {_yaw} to {_ply}.getHandle().yaw
			set {_pitch} to {_ply}.getHandle().pitch
			set {_shots} to 1
			set {_shots} to yml value "%{_itemType}%.shots" from file "plugins/Data/weapons.yml"
			set {_offSet} to yml value "%{_itemType}%.offSet" from file "plugins/Data/weapons.yml"
			set {_displayName} to yml value "%{_itemType}%.displayName.%trimText(name of {_rocket})%" from file "plugins/Data/weapons.yml"
			loop {_shots} times:
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
				if {_offSet} is set:
					set vector length of {_velocity} to {_offSet}
					{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
				if {_itemType} is "喜庆弹射器":
					if chance of 0.25:
						set {_displayName} to "红烟花火箭"
					else if chance of 0.33:
						set {_displayName} to "绿烟花火箭"
					else if chance of 0.5:
						set {_displayName} to "蓝烟花火箭"
					else:
						set {_displayName} to "黄烟花火箭"
				set vector length of {_velocity} to {_projectileSpeed}
				set {_rocketE} to mobProjectile({_ply}, {_velocity}, {_map}, {_displayName})
				
				set metadata "penetration" of {_rocketE} to {_attrMap}.getOrDefault("penetration", 0)
				set metadata "Bounce" of {_rocketE} to {_attrMap}.getOrDefault("bounce", 0)
				add "isGranade" to scoreboard tags of {_rocketE}
				if {_projectileThruWall} is true:
					add "thruWall" to scoreboard tags of {_rocketE}
				projectileAI({_rocketE}, {_weaponType})
			applyCD({_ply}, ceil({_attrMap}.get("useTime") * ({_attrMap}.get("useTimeMulti")) * ({_attrMap}.get("useTimeRangedMulti")) * 0.75))
		else:
			set metadata "autoSwing" of {_ply} to false
	set metadata "swingAmount" of {_ply} to (metadata "swingAmount" of {_ply}) + 1
function displayLoadingProgress(ply: player, maxLoad: number):
	set {_fillProgress} to ((metadata "swingAmount" of {_ply}) + 1) / {_maxLoad}
	if {_fillProgress} <= 0.2:
		set {_colorCode} to "§4"
	else if {_fillProgress} <= 0.4:
		set {_colorCode} to "§c"
	else if {_fillProgress} <= 0.6:
		set {_colorCode} to "§e"
	else if {_fillProgress} <= 0.8:
		set {_colorCode} to "§a"
	else:
		set {_colorCode} to "§2"
	set {_barLengthTotal} to 50
	set {_barLengthReady} to floor({_barLengthTotal} * {_fillProgress})
	set {_infoText} to "%{_colorCode}%装填:["
	loop {_barLengthTotal} times:
		if loop-number <= {_barLengthReady}:
			set {_infoText} to "%{_infoText}%|"
			if loop-number == {_barLengthReady}:
				set {_infoText} to "%{_infoText}%&8"
		else:
			set {_infoText} to "%{_infoText}%|"
	send subtitle "%{_infoText}%%{_colorCode}%]" to {_ply} for 0 tick with fade out 10 ticks
function handleZenith(ply: player, colorSword: text, destination: location, item: item, target: entity):
	set {_extra} to new HashMap()
	set {_toDamage} to new ArrayList()
	set {_color} to new ArrayList(1)
	{_color}.add({_colorSword})
	set {_v} to {_destination}.clone().subtract(eye location of {_ply}).toVector()
	if vector length of {_v} < 1:
		set {_v} to vector(0, 1, 0)
	set {_length} to (vector length of {_v}) / 2
	set vector length of {_v} to max({_length} - 1, 0.5)
	set {_midPt} to (eye location of {_ply}).add({_v})
	set {_yaw} to vector yaw of {_v} + 90
	set {_pitch} to vector pitch of {_v}
	set {_axisV} to vector with yaw {_yaw} and pitch (a random number between 90 and -90)
	set {_axisV} to {_v} cross {_axisV}
	if chance of 0.5:
		set {_negYaw} to true
	add 180 to {_yaw}
	set {_loopTime} to 90
	set {_dYaw} to 360 / {_loopTime}
	set {_col} to new ArrayList(1)
	{_col}.add("255|155|155")
	set {_loopInd} to 0
	loop {_loopTime} times:
		set {_lengthMulti} to abs(abs((loop-number/{_loopTime}) - 0.5) - 0.25) + 0.75
		
		set {_dV} to new vector with yaw {_yaw} and pitch 0
		set {_dV} to {_dV} cross {_axisV}
		set vector length of {_dV} to {_length} * {_lengthMulti}
		set {_loc} to {_midPt}.clone().add({_dV})
		{_extra}.put("startLocation", {_loc})
		handleStrikeLine({_ply}, (vector yaw of {_dV}), (vector pitch of {_dV}), 5, {_item}, {_color}, {_toDamage}, true, {_extra})
		
		if {_negYaw} is true:
			add {_dYaw} to {_yaw}
		else:
			subtract {_dYaw} from {_yaw}
		if loop-number = floor({_loopTime} / 2):
			{_target} is not {_ply}
			{_toDamage}.contains({_target}) is false
			distance between (eye location of {_target}) and {_loc} < 12
			if {_target} is not {_ply}:
				handleDamage({_target}, {_ply}, (metadata "attrMap" of {_ply}).get("damage"), "Melee")
			damageCD({_toDamage}, {_target}, 10)
		add 1 to {_loopInd}
		if {_loopInd} > 10:
			set {_loopInd} to 0
			add 1 to {_ddd}
			wait 2 ticks

function projectileAI(arrow: entity, weaponType: text):
	disguiseProjectile({_arrow})
	set {_weaponType} to {_weaponType} in uppercase
	set {_speed} to vector length of (velocity of {_arrow})
	set {_speed} to metadata "pSpeed" of {_arrow}
	set {_target} to metadata "followTarget" of {_arrow}
	set metadata "followTarget" of {_arrow} to {_target}
	set metadata "pType" of {_arrow} to {_weaponType}
	set metadata "pSpeed" of {_arrow} to {_speed}
	set {_loopTime} to 33
	set {_waitTime} to 6 tick
	set {_maxLiveTime} to 200
	set {_resetVelocity} to true
	set {_arrowName} to {_arrow}.getCustomName()
	#see if the projectile automatically tracks enemy
	if (yml value "%{_arrowName}%.autoTrace" from file "plugins/Data/entities.yml") is true:
		set {_autoTrace} to true
	if (yml value "%{_arrowName}%.thruWall" from file "plugins/Data/entities.yml") is true:
		add "thruWall" to scoreboard tags of {_arrow}
	if {_arrow} has scoreboard tag "thruWall":
		set {_arrow}.getHandle().noclip to true
	set {_trailColor} to yml value "%{_arrowName}%.trailColor" from file "plugins/Data/entities.yml"
	if {_arrowName} is "小火花" or "烈焰箭" or "希腊烈火" or "火焰":
		set {_loopTime} to 100
		set {_waitTime} to 2 ticks
		set {_maxLiveTime} to 200
	else if {_arrowName} is "手榴弹" or "炸弹" or "粘性炸弹" or "雷管" or "粘性雷管":
		set {_loopTime} to 1
		set {_waitTime} to 5 seconds
		set {_maxLiveTime} to 100
		set {_resetVelocity} to false
	else if {_arrowName} is "种子弯刀坚果" or "装饰":
		set {_loopTime} to 1
		set {_waitTime} to 15 ticks
		set {_maxLiveTime} to 15
		set {_resetVelocity} to false
	else if {_arrowName} is "夜明箭":
		set {_loopTime} to 10
		set {_waitTime} to 10 ticks
		set {_maxLiveTime} to 100
	else if {_arrowName} is "孢子球":
		set {_loopTime} to 75
		set {_waitTime} to 4 ticks
		set {_maxLiveTime} to 300
	else if {_arrowName} is "冰雪碎块" or "死神镰刀" or "火焰锄刀" or "星云奥秘":
		set {_loopTime} to 25
		set {_waitTime} to 4 ticks
		set {_maxLiveTime} to 100
	else if {_arrowName} is "气泡弹":
		set {_loopTime} to 20
		set {_waitTime} to 3 ticks
		set {_maxLiveTime} to 60
	else if {_arrowName} is "台风" or "彩虹水晶":
		set {_loopTime} to 30
		set {_waitTime} to 2 ticks
		set {_maxLiveTime} to 60
	else if {_arrowName} is "北极长矛":
		set {_loopTime} to 100
		set {_waitTime} to 2 ticks
		set {_maxLiveTime} to 200
		set {_attrMap} to metadata "attrMap" of {_arrow}
	else if {_arrowName} is "泰拉悠悠球光束":
		set {_loopTime} to 10
		set {_waitTime} to 3 ticks
		set {_maxLiveTime} to 30
	else if {_arrowName} ends with "强化焰":
		loop 240 times:
			if {_arrow}.getHandle().dead:
				stop trigger
			clear {_nearest}
			clear {_dV}
			set {_nearestDist} to 999
			loop all players in world of {_arrow}:
				gamemode of loop-player is survival
				set {_dist} to distance between loop-player and {_arrow}
				if {_dist} < {_nearestDist}:
					set {_nearest} to loop-player
					set {_nearestDist} to {_dist}
			set {_v} to velocity of {_arrow}
			if {_nearestDist} < 12:
				set {_dV} to (eye location of {_nearest}).subtract(location of {_arrow}).toVector()
				vector length of {_dV} > 0
				if vector length of {_v} > 0:
					set vector length of {_v} to min(sqrt(vector length of {_dV}), 4)
				set vector length of {_dV} to 4
				{_v}.add({_dV})
				set vector length of {_v} to (4 - sqrt({_nearestDist})) / 8
			else:
				set vector length of {_v} to max(0, vector length of {_v} * 0.95)
			set velocity of {_arrow} to {_v}
			wait 5 ticks
		{_arrow}.remove()
		stop trigger
	else:
		if {_weaponType} starts with "MAGIC":
			set {_loopTime} to 50
			set {_waitTime} to 4 tick
		else if {_weaponType} is "GUN" or "BULLET":
			set {_loopTime} to 50
			set {_waitTime} to 4 tick
		else if {_weaponType} is "BOW" or "ARROW":
			set {_loopTime} to 50
			set {_waitTime} to 4 ticks
			set {_resetVelocity} to false
		if {_autoTrace}:
			set {_loopTime} to 100
			set {_waitTime} to 2 tick
			set {_speed} to sqrt({_speed})
		if metadata "Bounce" of {_arrow} > 0:
			gravity of {_arrow} is on
			set {_loopTime} to 1
			set {_waitTime} to 5 seconds
			set {_resetVelocity} to false
	set {_v} to velocity of {_arrow}
	if {_arrowName} is "彩虹水晶":
		if {_arrow}.getTicksLived() < 2:
			set {_speed} to {_speed} * 3
			set metadata "pSpeed" of {_arrow} to {_speed}
			wait 15 ticks
	if vector length of {_v} > 0:
		set vector length of {_v} to {_speed}
	loop {_loopTime} times:
		if {_arrowName} is "夜明箭":
			loop-number = 2
			set {_spawnLoc} to {_arrow}.getOrigin()
			set {_shooter} to shooter of {_arrow}
			set {_attrMap} to metadata "attrMap" of {_arrow}
			set {_arrowE} to (world of {_arrow}).spawnEntity({_spawnLoc}, EntityType.SNOWBALL)
			{_arrowE}.setCustomName("光束箭")
			set glowing of {_arrowE} to on
			set gravity of {_arrowE} to off
			set shooter of {_arrowE} to {_shooter}
			set velocity of {_arrowE} to {_v}
			play sound "item.bowShoot" with volume 2 and pitch 1 at {_spawnLoc}
			set metadata "attrMap" of {_arrowE} to {_attrMap}
			set metadata "penetration" of {_arrowE} to 3
			projectileAI({_arrowE}, "GUN")
		if {_arrowName} is "北极长矛":
			set {_snowFlake} to spawnProjectile({_arrow}, vector(0, 0, 0), {_attrMap}, "北极雪花", (location of {_arrow}))
			set metadata "damageSourcePlayer" of {_snowFlake} to shooter of {_arrow}
		if {_trailColor} is set:
			{_lastLoc} is set
			set {_trailVec} to (location of {_arrow}).subtract({_lastLoc}).toVector()
			handleParticleLine({_trailVec}, (vector length of {_trailVec}), 0.12, {_lastLoc}, {_trailColor})
		set {_lastLoc} to location of {_arrow}
		if {_arrow}.getHandle().dead:
			stop trigger
		if {_arrow}.getTicksLived() > {_maxLiveTime}:
			stop loop
		if block at location of {_arrow} is water:
			if {_arrowName} is "小火花" or "希腊烈火" or "火焰":
				stop loop
			else if {_arrowName} is "烈焰箭":
				{_arrow}.setCustomName("木箭")
		if {_autoTrace}:
			if {_arrow} has scoreboard tag "reflected":
				clear {_autoTrace}
			else:
				if {_target} is set:
					if health of {_target} <= 0:
						clear {_target}
						clear metadata "followTarget" of {_arrow}
					else if checkCanDamage(shooter of {_arrow}, {_target}) is not true:
						clear metadata "followTarget" of {_arrow}
						clear {_target}
					else if (try (metadata "collided" of {_arrow}).contains({_target})) is true:
						clear {_target}
						clear metadata "followTarget" of {_arrow}
				if {_target} is not set:
					clear {_candidate::*}
					loop all living entities in radius 12 of {_arrow}:
						set {_currEntity} to loop-value-2
						{_currEntity} is not a player
						{_currEntity} is not {_arrow}.getShooter()
						checkCanDamage(shooter of {_arrow}, {_currEntity}) is true
						{_currEntity}.hasLineOfSight({_arrow})
						health of {_currEntity} > 0
						if (try (metadata "collided" of {_arrow}).contains({_currEntity})) is true:
							add {_currEntity} to {_candidate::*}
						else:
							set {_target} to {_currEntity}
							set metadata "followTarget" of {_arrow} to {_currEntity}
							stop loop
					if {_target} is not set:
						{_candidate::1} is set
						set {_target} to a random element out of {_candidate::*}
						set metadata "followTarget" of {_arrow} to {_target}
				if {_target} is set:
					set {_v} to velocity of {_arrow}
					set {_dV} to (eye location of {_target}).subtract(location of {_arrow}).toVector()
					vector length of {_dV} > 0
					if vector length of {_v} > 0:
						set vector length of {_v} to min(sqrt(vector length of {_dV}), 4)
					set vector length of {_dV} to 4
					{_v}.add({_dV})
					set vector length of {_v} to {_speed}
				set velocity of {_arrow} to {_v}
		else:
			set {_v} to velocity of {_arrow}
			if {_resetVelocity} is true:
				vector length of {_v} > 0
				set vector length of {_v} to {_speed}
			if {_arrowName} is "恶魔之镰" or "火焰锄刀":
				set {_speed} to min({_speed} * 1.2, 1.7)
			else if {_arrowName} is "死神镰刀":
				set {_speed} to max({_speed} * 0.95, 0.01)
			set velocity of {_arrow} to {_v}
		wait {_waitTime}
	{_arrow}.isDead() is false
	handleProjectileDestroy({_arrow})
	{_arrow}.remove()
function shootYoyo(ply: player, itemType: text, item: item):
	set {_attrMap} to (metadata "attrMap" of {_ply}).clone()
	set {_yoyo} to (world of {_ply}).spawnEntity((eye location of {_ply}), EntityType.SLIME)
	set {_yoyo}.getHandle().goalSelector to new PathfinderGoalSelector({_yoyo}.getHandle().getWorld().methodProfiler)
	set max health of {_yoyo} to 222
	set health of {_yoyo} to 222
	applyCD({_ply}, -1)
	set {_vecRecoil} to vector(0, 0, 0)
	set {_time} to 0
	set {_reach} to 8
	set {_speed} to 16
	set {_timeTotal} to 100
	set {_typeID} to 0
	set {_reach} to yml value "%{_itemType}%.reach" from file "plugins/Data/weapons.yml"
	set {_speed} to yml value "%{_itemType}%.velocity" from file "plugins/Data/weapons.yml"
	set {_typeID} to yml value "%{_itemType}%.typeID" from file "plugins/Data/weapons.yml"
	set {_speed} to {_speed} / 20
	set {_reach} to {_reach} * ({_attrMap}.getOrDefault("meleeReachMulti", 1))
	set {_timeTotal} to yml value "%{_itemType}%.duration" from file "plugins/Data/weapons.yml"
	set {_useTime} to {_attrMap}.getOrDefault("useTime", 10) * ({_attrMap}.getOrDefault("useTimeMulti", 1)) * ({_attrMap}.getOrDefault("useTimeMeleeMulti", 1))
	set metadata "damageSourcePlayer" of {_yoyo} to {_ply}
	set metadata "attrMap" of {_yoyo} to {_attrMap}
	add "noDamage" to scoreboard tags of {_yoyo}
	{_yoyo}.setRemoveWhenFarAway(false)
	{_yoyo}.setCustomName("%{_itemType}%")
	{_yoyo}.setCustomNameVisible(true)
	set {_size} to 1
	if {_typeID} = 1:
		set {_size} to 2
	slimeResize({_yoyo}, {_size})
	set {_size} to 0.3 * {_size}
	set gravity of {_yoyo} to off
	set {_meleeCD} to new ArrayList(10)
	set {_world} to world of {_yoyo}
	set {_yoyoLoc} to location of {_yoyo}
	wait 1 tick
	makeTarget({_yoyo}, {_ply})
	set {_index} to 0
	while {_ply} is online:
		if health of {_yoyo} <= 0:
			stop loop
		if gamemode of {_ply} is spectator:
			stop loop
		if world of {_ply} is not world of {_yoyo}:
			stop loop
		
		if mod({_index}, 3) = 0:
			set {_dir} to "OUT"
			add 3 to {_time}
			if {_time} >= {_timeTotal}:
				{_timeTotal} > 0
				set {_dir} to "FORCE_IN"
			else if distance between ({_yoyoLoc}) and (location of {_ply}) > {_reach}:
				if {_typeID} is 1:
					set {_time} to {_timeTotal}
				set {_dir} to "IN"
			else if {_ply} is sneaking:
				{_typeID} is 0
				set {_dir} to "IN"
			if {_typeID} = 1:
				metadata "autoSwing" of {_ply} is true
				set {_dir} to "SWING"
		if {_dir} is "SWING":
			mod({_index}, 2) = 0
			set {_time} to 0
			clear {_velocity}
			set velocity of {_yoyo} to vector(0, 0, 0)
			set {_yaw} to mod(({_index} * 25), 360) - 180
			set {_dV} to new vector with yaw {_yaw} and pitch 0
			set vector length of {_dV} to 2
			set {_location} to (location of {_ply}).add(0, 1, 0).add({_dV})
			teleport {_yoyo} to {_location}
		else if mod({_index}, 3) = 0:
			set {_renewVelocity} to true
			if {_typeID} = 1:
				{_velocity} is set
				{_dir} is "OUT"
				set {_renewVelocity} to false
			if {_renewVelocity}:
				if {_dir} is "IN" or "FORCE_IN":
					set {_velocity} to {_ply}.getEyeLocation().subtract({_yoyoLoc}).toVector()
					distance between {_ply}.getEyeLocation() and {_yoyoLoc} <= (1.5 + {_speed})
					stop loop
				else:
					if {_typeID} = 1:
						teleport {_yoyo} to eye location of {_ply}
						set {_yoyoLoc} to location of {_yoyo}
					clear {_loc}
					if {_ply} has metadata "target":
						if metadata "target" of {_ply} is living entity:
							set {_loc} to (metadata "target" of {_ply}).getEyeLocation()
						else:
							set {_loc} to (metadata "target" of {_ply}).getLocation()
					else if targeted block of {_ply} is set:
						set {_loc} to (location of targeted block of {_ply}).add(0.5, 1, 0.5)
					if {_loc} is set:
						set {_velocity} to {_loc}.subtract({_yoyoLoc}).toVector()
					else:
						set {_yaw} to {_ply}.getHandle().yaw
						set {_pitch} to {_ply}.getHandle().pitch
						set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
					if {_typeID} = 1:
						set {_lastV} to {_velocity}.clone()
						set vector length of {_lastV} to 1
				set vector length of {_velocity} to {_speed}
				{_velocity}.add({_vecRecoil})
				{_vecRecoil}.multiply(0.5)
			
		if mod({_index}, 3) = 0:
			if {_velocity} is set:
				set {_dLoc} to {_velocity}.clone().multiply(3)
				if {_typeID} is 1:
					set {_currV} to velocity of {_yoyo}
					if vector length of {_currV} > 0:
						set vector length of {_currV} to 1
						if {_lastV} dot {_currV} < 0.99:
							set {_time} to {_timeTotal}
				if {_dir} is "FORCE_IN":
					teleport {_yoyo} to ({_yoyoLoc}.add({_dLoc}))
				set velocity of {_yoyo} to {_velocity}
				set {_yoyoLoc} to location of {_yoyo}
			
			if {_itemType} is "泰拉悠悠球":
				set {_velocityProjectile} to new vector with yaw (a random number between 180 and -180) and pitch (a random number between 90 and -90)
				set vector length of {_velocityProjectile} to 0.15
				loop all entities in radius 5 of {_yoyo}:
					health of loop-value > 0
					checkCanDamage({_yoyo}, loop-value) is true
					set {_velocityProjectile} to (location of loop-value).subtract(eye location of {_yoyo}).toVector()
					if vector length of {_velocityProjectile} = 0:
						set {_velocityProjectile} to vector(0, -1, 0)
					set vector length of {_velocityProjectile} to 0.25
					stop loop
				set {_projectile} to mobProjectile({_yoyo}, {_velocityProjectile}, {_attrMap}, "泰拉悠悠球光束")
				set gravity of {_projectile} to off
				set metadata "bounce" of {_projectile} to 3
				projectileAI({_projectile}, "BOW")
			if {_itemType} is "猪鲨链球":
				set {_velocityProjectile} to new vector with yaw (a random number between 180 and -180) and pitch (a random number between 90 and -90)
				set vector length of {_velocityProjectile} to 0.15
				set {_projectile} to mobProjectile({_yoyo}, {_velocityProjectile}, {_attrMap}, "气泡弹")
				set gravity of {_projectile} to off
				projectileAI({_projectile}, "BOW")
		
		#check collision
		if mod({_index}, 2) = 0:
			set {_entities} to {_yoyo}.getWorld().getNearbyEntities((location of {_yoyo}).clone().add(0.125, 0.125, 0.125), {_size}, {_size}, {_size})
			loop ...{_entities}:
				set {_victim} to loop-value
				{_victim} is living entity
				{_victim} is not {_ply}
				{_meleeCD}.contains({_victim}) is false
				if checkCanDamage({_yoyo}, {_victim}):
					handleDamage({_victim}, {_yoyo}, {_attrMap}.get("damage"), "Melee")
					damageCD({_meleeCD}, {_victim}, 5)
					if {_typeID} is 0:
						set {_recoil} to {_yoyoLoc}.clone().subtract({_victim}.getEyeLocation()).toVector()
						set vector length of {_recoil} to 0.3
						{_vecRecoil}.add({_recoil})
						add 4 to {_time}
	
		wait 1 tick
		add 1 to {_index}
	
	{_yoyo}.remove()
	applyCD({_ply}, {_useTime})
function shootBoomerang(ply: player, itemType: text, item: item):
	set {_attrMap} to metadata "attrMap" of {_ply}
	if {_ply} has scoreboard tag "PVP":
		set {_pvp} to true
	else:
		set {_pvp} to false
	applyCD({_ply}, -1)
	set {_return} to false
	set {_yaw} to {_ply}.getHandle().yaw
	set {_pitch} to {_ply}.getHandle().pitch
	set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
	set {_penetration} to yml value "%{_itemType}%.penetration" from file "plugins/Data/weapons.yml"
	set {_speed} to yml value "%{_itemType}%.velocity" from file "plugins/Data/weapons.yml"
	set {_speed} to ({_speed} / 5) / ({_attrMap}.getOrDefault("useTimeMeleeMulti", 1))
	set {_lastWaited} to true
	set {_distTraveled} to 0
	set {_maxDistance} to {_speed} * 12
	set {_maxDistance} to {_maxDistance} * ({_attrMap}.getOrDefault("meleeReachMulti", 1))
	set vector length of {_velocity} to 1
	set {_loc} to {_ply}.getEyeLocation()
	set {_damagedEntities} to new ArrayList()
	set {_dmg} to {_attrMap}.get("damage")
	set {_useTime} to {_attrMap}.getOrDefault("useTime", 10) * ({_attrMap}.getOrDefault("useTimeMulti", 1)) * ({_attrMap}.getOrDefault("useTimeMeleeMulti", 1))
	set {_originalLoc} to {_ply}.getLocation()
	while {_ply} is online:
		if world of {_loc} is not world of {_ply}:
			stop loop
		set {_toLoop} to {_loc}.getWorld().getNearbyEntities({_loc}, 0.5, 0.5, 0.5)
		set {_iterator} to {_toLoop}.iterator()
		while {_iterator}.hasNext() is true:
			set {_damage} to true
			set {_entity1} to {_iterator}.next()
			checkMeleeTarget({_entity1}) is true
			if {_entity1} is {_ply}:
				{_return} is true:
					stop 2 loops
			set {_damage} to checkCanDamage({_ply}, {_entity1})
			if {_damage} is true:
				if {_damagedEntities}.contains({_entity1}) is false:
					handleDamage({_entity1}, {_ply}, {_dmg}, "Melee")
					if {_return} is false:
						{_penetration} is not true
						set {_return} to true
						set {_damagedEntities} to new ArrayList()
					{_damagedEntities}.add({_entity1})
		set {_locNext} to {_loc}.clone().add({_velocity})
		add 1 to {_distTraveled}
		if {_return} is false:
			set {_block} to (block at {_locNext})
			if {_block}.getType().isSolid() is true:
				set {_return} to true
				set {_damagedEntities} to new ArrayList()
			if {_loc}.distance({_originalLoc}) > {_maxDistance}:
				set {_return} to true
				set {_damagedEntities} to new ArrayList()
		else:
			if {_lastWaited} is true:
				set {_velocity} to (eye location of {_ply}).subtract({_loc}).toVector()
				set vector length of {_velocity} to 1
			
			if distance between eye location of {_ply} and {_loc} <= 1.5:
				stop loop
		set {_loc} to {_locNext}
		draw 5 itemcrack particles made of {_item} at {_loc}, speed 0, offset 0.1, 0.1, 0.1, visibleRange 64, keepFor 1 tick
		if {_distTraveled} > {_speed}:
			subtract {_speed} from {_distTraveled}
			set {_lastWaited} to true
			wait 2 ticks
		else:
			set {_lastWaited} to false
	applyCD({_ply}, {_useTime})
function sentryAI(sentry: entity, owner: player, nameSentry: text):
	add "noDamage" to scoreboard tags of {_sentry}
	add "isMinion" to scoreboard tags of {_sentry}
	add "noMelee" to scoreboard tags of {_sentry}
	set {_sentryList} to metadata "sentries" of {_owner}
	set {_sentryIndex} to metadata "nextSentryIndex" of {_owner}
	set {_sentryLimit} to (metadata "attrMap" of {_owner}).get("sentryLimit")
	if {_sentryList}.size() < {_sentryLimit}:
		set {_sentryIndex} to {_sentryList}.size()
	else:
		set {_sentryIndex} to mod({_sentryIndex}, {_sentryLimit})
	if {_sentryIndex} < {_sentryList}.size():
		try {_sentryList}.get({_sentryIndex}).remove()
		{_sentryList}.set({_sentryIndex}, {_sentry})
	else:
		{_sentryList}.add({_sentry})
	set metadata "nextSentryIndex" of {_owner} to mod({_sentryIndex} + 1, {_sentryLimit})
	set metadata "damageSourcePlayer" of {_sentry} to {_owner}
	set {_attrMap} to metadata "attrMap" of {_sentry}
	{_sentry}.setRemoveWhenFarAway(false)
	{_sentry}.setCustomName("%{_nameSentry}%")
	{_sentry}.setCustomNameVisible(true)
	set AI of {_sentry} to false
	set {_index} to 0
	set {_idx} to 0
	set {_damageType} to {_attrMap}.get("damageType")
	if {_damageType} is "Melee":
		set {_meleeCD} to new ArrayList()
	set {_staffMulti} to metadata "toolDmgMulti" of {_owner}
	{_attrMap}.put("damage%{_damageType}%Multi", {_attrMap}.getOrDefault("damageSummonMulti", 1))
	{_attrMap}.put("crit", 0)
	
	set {_slimeSize} to 3
	set {_targetRange} to 48
	if {_nameSentry} is "七彩水晶":
		set {_particleColor} to new ArrayList(6)
		{_particleColor}.add("255|0|0")
		{_particleColor}.add("255|255|0")
		{_particleColor}.add("0|255|0")
		{_particleColor}.add("0|255|255")
		{_particleColor}.add("0|0|255")
		{_particleColor}.add("255|0|255")
		set gravity of {_sentry} to off
	else if {_nameSentry} is "月亮传送门":
		set {_particleColor} to new ArrayList(1)
		{_particleColor}.add("0|225|125")
		set {_advanced} to new HashMap(3)
		{_advanced}.put("particleInterval", 1)
		set {_meleeCD} to new ArrayList()
		set gravity of {_sentry} to off
		set {_targetRange} to 64
	else if {_nameSentry} is "蜘蛛女王":
		set {_targetRange} to 24
	slimeResize({_sentry}, {_slimeSize})
		
	set {_target} to {_owner}
	set {_sentryLoc} to location of {_sentry}
	
	# alive for at most 5 minutes
	loop 2000 times:
		if {_owner} is not online:
			stop loop
		if {_owner} has scoreboard tag "unauthorized":
			stop loop
		if mod({_idx}, 3) = 0:
			set {_currToolMulti} to 0
			set {_currToolMulti} to metadata "toolDmgMulti" of {_owner}
			set {_attrMapOwner} to new HashMap(1)
			set {_attrMapOwner} to metadata "attrMap" of {_owner}
			{_attrMap}.put("damageMulti", {_attrMapOwner}.getOrDefault("damageMulti", 1))
			{_attrMap}.put("damage%{_damageType}%Multi", {_attrMapOwner}.getOrDefault("damageSummonMulti", 1))
			tweakAttribute({_attrMap}, "damageMulti", {_currToolMulti}, false)
			tweakAttribute({_attrMap}, "damageMulti", {_staffMulti}, true)
			if health of {_sentry} <= 0:
				stop loop
			if {_sentry}.isDead() is true:
				stop loop
			if gamemode of {_owner} is spectator:
				stop loop
			if {_sentryIndex} >= (metadata "attrMap" of {_owner}).getOrDefault("sentryLimit", 1):
				wait 10 ticks
				{_sentryIndex} >= (metadata "attrMap" of {_owner}).getOrDefault("sentryLimit", 1)
				stop loop
			if {_sentryList}.get({_sentryIndex}) is not {_sentry}:
				stop loop
		if checkCanDamage({_owner}, {_target}) is false:
			{_owner} is not {_target}
			set {_clearTarget} to true
		else if health of {_target} <= 0:
			set {_clearTarget} to true
		else if {_target}.isDead() is true:
			set {_clearTarget} to true
		else if distance between {_target} and {_sentry} > {_targetRange}:
			set {_clearTarget} to true
		else if {_sentry}.hasLineOfSight({_target}) is false:
			set {_clearTarget} to true
		if {_clearTarget} is true:
			set {_clearTarget} to false
			set {_target} to {_owner}
		else:
			if {_target} is not set:
				set {_target} to {_owner}
			
			set {_reTarget} to false
			if {_target} is {_owner}:
				set {_reTarget} to true
			if {_reTarget} is true:
				set {_dist} to 999
				loop all living entities in radius {_targetRange} of {_sentry}:
					set {_currCheckTarget} to loop-value-2
					health of {_currCheckTarget} > 0
					{_currCheckTarget} is not a player
					{_currCheckTarget} doesn't have scoreboard tag "isNPC"
					checkCanDamage({_owner}, {_currCheckTarget}) is true
					set {_hasSight} to false
					if {_sentry}.hasLineOfSight({_currCheckTarget}) is true:
						set {_hasSight} to true
					if {_hasSight}:
						set {_distance} to distance between {_currCheckTarget} and {_sentry}
						if {_distance} < {_dist}:
							set {_target} to {_currCheckTarget}
							set {_dist} to {_distance}
			if {_nameSentry} is "蜘蛛女王":
				if mod({_index}, 7) = 0:
					{_target} is not {_owner}
					set {_v} to (eye location of {_target}).subtract(eye location of {_sentry}).toVector()
					vector length of {_v} > 0
					set vector length of {_v} to 2.5
					set {_bulletE} to (world of {_sentry}).spawnEntity((eye location of {_sentry}), EntityType.SPLASH_POTION)
					set metadata "attrMap" of {_bulletE} to {_attrMap}
					{_bulletE}.setVelocity({_v})
					{_bulletE}.setShooter({_sentry})
					{_bulletE}.setCustomName("蜘蛛卵")
					projectileAI({_bulletE}, "ARROW")
			else if {_nameSentry} is "月亮传送门":
				if {_target} is {_owner}:
					mod({_index}, 17) < 5
					clear {_yaw}
					clear {_pitch}
				else:
					if mod({_index}, 17) = 5:
						set {_v} to (eye location of {_target}).subtract(eye location of {_sentry}).toVector()
						if vector length of {_v} < 0.01:
							set {_v} to vector(0, -1, 0)
						set {_yaw} to vector yaw of {_v}
						set {_pitch} to vector pitch of {_v} + 2
				if mod({_index}, 17) >= 5:
					{_yaw} is set
					set {_yawTemp} to {_yaw} - 1
					loop 2 times:
						set {_pitchTemp} to {_pitch} - 1
						loop 2 times:
							handleStrikeLine({_sentry}, {_yawTemp}, {_pitchTemp}, 64, (a diamond), {_particleColor}, {_meleeCD}, false, {_advanced})
							add 2 to {_pitchTemp}
						add 2 to {_yawTemp}
					subtract 1 from {_pitch}
			else if {_nameSentry} is "七彩水晶":
				if mod({_index}, 4) = 0:
					if mod(({_index} / 4), 2) = 0:
						set {_loopInd} to 1
					else:
						set {_loopInd} to 10
					loop 9 times:
						set {_loopIdx} to {_loopInd} + loop-number-2
						if {_locationExplode::%{_loopIdx}%} is set:
							handleEntityExplodeAtLoc({_sentry}, {_sentry}, {_locationExplode::%{_loopIdx}%})
							clear {_locationExplode::%{_loopIdx}%}
						else:
							stop loop
					if {_target} is not {_owner}:
						set {_color} to new ArrayList(1)
						{_color}.add({_particleColor}.get(a random integer between 0 and (({_particleColor}.size()) - 1)))
						set {_lastLoc} to location of {_target}
						wait 1 tick
						set {_offSet} to (location of {_target}).subtract({_lastLoc}).toVector()
						if vector length of {_offSet} > 0:
							set vector length of {_offSet} to (vector length of {_offSet}) * 12
						set {_predictedLoc} to (eye location of {_target}).add({_offSet})
						loop (a random integer between 3 and 5) times:
							set {_targetLoc} to {_predictedLoc}.clone().add((a random number between -4 and 4), (a random number between 0 and 4), (a random number between -4 and 4))
							set {_locationExplode::%{_loopInd}%} to {_targetLoc}
							add 1 to {_loopInd}
							set {_v} to {_targetLoc}.clone().subtract(eye location of {_sentry}).toVector()
							handleParticleLine({_v}, (vector length of {_v}), 0.25, (eye location of {_sentry}), {_color})
		add 1 to {_index}
		add 1 to {_idx}
		wait 3 ticks
	
	{_sentryList}.remove({_sentry})
	{_sentry}.remove()
function minionAI(minion: entity, owner: player, nameMinion: text, minionSlot: number):
	add "noDamage" to scoreboard tags of {_minion}
	add "isMinion" to scoreboard tags of {_minion}
	set {_minionList} to metadata "minions" of {_owner}
	set {_minionIndex} to metadata "nextMinionIndex" of {_owner}
	set {_minionLimit} to (metadata "attrMap" of {_owner}).get("minionLimit")
	set {_minionIdx} to {_minionIndex}
	loop {_minionSlot} times:
		if {_minionList}.size() < {_minionLimit}:
			set {_minionIdx} to {_minionList}.size()
		else:
			set {_minionIdx} to mod({_minionIdx}, {_minionLimit})
		if {_minionIdx} < {_minionList}.size():
			try {_minionList}.get[int]({_minionIdx}).remove()
			{_minionList}.set({_minionIdx}, {_minion})
		else:
			{_minionList}.add({_minion})
		add 1 to {_minionIdx}
	set metadata "nextMinionIndex" of {_owner} to mod({_minionIdx}, {_minionLimit})
	set metadata "damageSourcePlayer" of {_minion} to {_owner}
	set {_attrMap} to metadata "attrMap" of {_minion}
	{_minion}.setRemoveWhenFarAway(false)
	{_minion}.setCustomName("%{_nameMinion}%")
	{_minion}.setCustomNameVisible(true)
	set {_index} to 0
	set {_idx} to 0
	set {_damageType} to {_attrMap}.get("damageType")
	if {_damageType} is "Melee":
		set {_meleeCD} to new ArrayList()
	set {_staffMulti} to metadata "toolDmgMulti" of {_owner}
	{_attrMap}.put("damage%{_damageType}%Multi", {_attrMap}.getOrDefault("damageSummonMulti", 1))
	{_attrMap}.put("crit", 0)
	
	if {_nameMinion} is "星尘之龙":
		set {_protectOwner} to false
	else:
		set {_protectOwner} to true
	
	if {_nameMinion} is "史莱姆宝宝":
		{_minion}.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED).setBaseValue(1.3d)
	else if {_nameMinion} is "蜘蛛":
		{_minion}.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED).setBaseValue(0.6d)
		apply potion of jump boost 10 without particles to {_minion} for 10 days
		add "noMelee" to scoreboard tags of {_minion}
	else if {_nameMinion} is "矮人":
		set tool of {_minion} to diamond sword
		{_minion}.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED).setBaseValue(0.4d)
		add "noMelee" to scoreboard tags of {_minion}
	else:
		set {_minion}.getHandle().goalSelector to new PathfinderGoalSelector({_minion}.getHandle().getWorld().methodProfiler)
		if {_nameMinion} is "附魔飞刀" or "星尘之龙" or "星尘细胞" or "泰拉棱镜":
			set {_minion}.getHandle().noclip to true
			set gravity of {_minion} to off
			if {_nameMinion} is "星尘之龙":
				slimeResize({_minion}, 2)
			else if {_nameMinion} is "泰拉棱镜":
				set {_particleColor} to new ArrayList(6)
				{_particleColor}.add("255|0|0")
				{_particleColor}.add("255|255|0")
				{_particleColor}.add("0|255|0")
				{_particleColor}.add("0|255|255")
				{_particleColor}.add("0|0|255")
				{_particleColor}.add("255|0|255")
				set {_yaw} to 0
				set {_pitch} to 90
			else if {_nameMinion} is "星尘细胞":
				set {_teleportCD} to 5
				set {_trailColor} to new ArrayList(1)
				{_trailColor}.add("102|204|255")
		else if {_nameMinion} is "致命球":
			set gravity of {_minion} to off
		else if {_nameMinion} is "小鬼" or "钨钢无人机":
			set gravity of {_minion} to off
			set {_minion}.getHandle().noclip to true
		else:
			set gravity of {_minion} to off
			if {_nameMinion} is "小激光眼":
				set {_rotationIndex} to a random number between 0 and 360
				set {_cousin} to {_minion}.getWorld().spawnEntity((location of {_minion}), EntityType.SLIME)
				slimeResize({_cousin}, 1)
				set {_attrMapCousin} to {_attrMap}.clone()
				{_attrMapCousin}.put("damageType", "Melee")
				set metadata "attrMap" of {_cousin} to {_attrMapCousin}
				set max health of {_cousin} to 222
				set health of {_cousin} to 222
				{_cousin}.setCustomName("小魔焰眼")
				{_cousin}.setCustomNameVisible(true)
				{_cousin}.setRemoveWhenFarAway(false)
				add "noDamage" to scoreboard tags of {_cousin}
				add "isMinion" to scoreboard tags of {_cousin}
				set metadata "damageSourcePlayer" of {_cousin} to {_owner}
				set gravity of {_cousin} to off
				set {_meleeCD} to new ArrayList(6)
	set {_target} to {_owner}
	set {_minionLoc} to location of {_minion}
	
	while {_owner} is online:
		if {_owner} has scoreboard tag "unauthorized":
			stop loop
		if {_cousin} is set:
			set {_entities} to {_cousin}.getWorld().getNearbyEntities({_cousin}.getLocation().add(0.125, 0.125, 0.125), 0.3, 0.3, 0.3)
			loop ...{_entities}:
				set {_victim} to loop-value
				{_victim} is living entity
				{_victim} is not {_owner}
				{_meleeCD}.contains({_victim}) is false
				if checkCanDamage({_cousin}, {_victim}) is not false:
					handleDamage({_victim}, {_cousin}, {_attrMap}.get("damage"), "Melee")
					damageCD({_meleeCD}, {_victim}, 5)
		if mod({_idx}, 3) = 0:
			set {_currToolMulti} to 0
			set {_currToolMulti} to metadata "toolDmgMulti" of {_owner}
			set {_attrMapOwner} to new HashMap(1)
			set {_attrMapOwner} to metadata "attrMap" of {_owner}
			{_attrMap}.put("damageMulti", {_attrMapOwner}.getOrDefault("damageMulti", 1))
			{_attrMap}.put("damage%{_damageType}%Multi", {_attrMapOwner}.getOrDefault("damageSummonMulti", 1))
			tweakAttribute({_attrMap}, "damageMulti", {_currToolMulti}, false)
			tweakAttribute({_attrMap}, "damageMulti", {_staffMulti}, true)
			if {_cousin} is set:
				{_attrMapCousin}.put("damageMulti", {_attrMapOwner}.getOrDefault("damageMulti", 1))
				{_attrMapCousin}.put("damageMeleeMulti", {_attrMapOwner}.getOrDefault("damageSummonMulti", 1))
			if health of {_minion} <= 0:
				stop loop
			if gamemode of {_owner} is spectator:
				stop loop
			if {_minionIndex} >= (metadata "attrMap" of {_owner}).getOrDefault("minionLimit", 1):
				wait 10 ticks
				{_minionIndex} >= (metadata "attrMap" of {_owner}).getOrDefault("minionLimit", 1)
				stop loop
			if try {_minionList}.get({_minionIndex}) is not {_minion}:
				stop loop
		set {_distX} to ((x-coordinate of {_minion}) - (x-coordinate of {_owner}))
		set {_distZ} to ((z-coordinate of {_minion}) - (z-coordinate of {_owner}))
		set {_distHor} to max(abs({_distX}), abs({_distZ}))
		if world of {_owner} is not world of {_minion}:
			teleport {_minion} to location of {_owner}
			if {_cousin} is set:
				teleport {_cousin} to location of {_owner}
			set {_minionLoc} to location of {_owner}
			set {_clearTarget} to true
		else if world of {_target} is not world of {_minion}:
			set {_clearTarget} to true
		else if {_distHor} > 60:
			teleport {_minion} to location of {_owner}
			if {_cousin} is set:
				teleport {_cousin} to location of {_owner}
			set {_minionLoc} to location of {_owner}
			set {_clearTarget} to true
		else if checkCanDamage({_owner}, {_target}) is false:
			{_owner} is not {_target}
			set {_clearTarget} to true
		else if health of {_target} <= 0:
			set {_clearTarget} to true
		else if {_target}.isDead() is true:
			set {_clearTarget} to true
		else if {_minion}.hasLineOfSight({_target}) is false:
			{_nameMinion} is not "星尘之龙"
			set {_clearTarget} to true
			if {_cousin} is set:
				{_cousin}.hasLineOfSight({_target}) is true
				set {_clearTarget} to false
		if {_clearTarget} is true:
			set {_clearTarget} to false
			if {_target} is {_whipTarget}:
				clear metadata "minionWhipFocus" of {_owner}
			set {_target} to {_owner}
		else:
			clear {_whipTarget}
			set {_whipTarget} to metadata "minionWhipFocus" of {_owner}
			set {_target} to {_whipTarget}
			if {_target} is not set:
				set {_target} to {_owner}
			
			set {_reTarget} to false
			if {_target} is {_owner}:
				set {_reTarget} to true
			else if {_protectOwner} is true:
				{_index} = 0
				set {_reTarget} to true
			if {_reTarget} is true:
				set {_dist} to 999
				loop all living entities in radius 48 of {_minion}:
					health of loop-value > 0
					loop-value is not a player
					loop-value doesn't have scoreboard tag "isNPC"
					checkCanDamage({_owner}, loop-value) is true
					set {_hasSight} to false
					if {_nameMinion} is "星尘之龙":
						set {_hasSight} to true
					else if {_minion}.hasLineOfSight(loop-value) is true:
						set {_hasSight} to true
					else if {_cousin} is set:
						{_cousin}.hasLineOfSight(loop-value) is true
						set {_hasSight} to true
					if {_hasSight}:
						set {_distance} to distance between loop-value and {_owner}
						if {_distance} < {_dist}:
							set {_target} to loop-value
							set {_dist} to {_distance}
							if {_protectOwner} is false:
								set {_dist} to -1
								stop loop
				{_dist} > 0
				loop all living entities in radius 24 of {_owner}:
					health of loop-value > 0
					loop-value is not a player
					loop-value doesn't have scoreboard tag "isNPC"
					checkCanDamage({_owner}, loop-value) is true
					set {_hasSight} to false
					if {_nameMinion} is "星尘之龙":
						set {_hasSight} to true
					else if {_minion}.hasLineOfSight(loop-value) is true:
						set {_hasSight} to true
					else if {_cousin} is set:
						{_cousin}.hasLineOfSight(loop-value) is true
						set {_hasSight} to true
					if {_hasSight}:
						set {_distance} to distance between loop-value and {_owner}
						if {_distance} < {_dist}:
							set {_target} to loop-value
							set {_dist} to {_distance}
							if {_protectOwner} is false:
								set {_dist} to -1
								stop loop
			if {_nameMinion} is "小鬼" or "钨钢无人机":
				if {_nameMinion} is "小鬼":
					{_minion}.setCustomName("小鬼§%floor(mod({_index}, 8) / 2)%")
				set {_targetLoc} to (eye location of {_target}).add(0, 3, 0)
				set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
				vector length of {_dVec} > 0
				set vector length of {_dVec} to min((vector length of {_dVec} / 12), 1)
				set velocity of {_minion} to {_dVec}
				
				if {_index} >= 0:
					{_target} is not {_owner}
					set {_v} to (eye location of {_target}).subtract(location of {_minion}).toVector()
					vector length of {_v} > 0
					if {_nameMinion} is "小鬼":
						set vector length of {_v} to 1.5
					else:
						set vector length of {_v} to 1
					set {_bulletE} to {_minion}.getWorld().spawnEntity({_minion}.getEyeLocation(), EntityType.SPLASH_POTION)
					set metadata "attrMap" of {_bulletE} to {_attrMap}
					{_bulletE}.setVelocity({_v})
					{_bulletE}.setShooter({_minion})
					if {_nameMinion} is "小鬼":
						{_bulletE}.setCustomName("小火花")
						set metadata "penetration" of {_bulletE} to 1
					else:
						{_bulletE}.setCustomName("钨钢光球")
					set gravity of {_bulletE} to off
					projectileAI({_bulletE}, "GUN")
					set {_index} to a random integer between -5 and -10
			else if {_nameMinion} is "蜘蛛":
				if {_target} is not {_owner}:
					if {_teleport} is {_target}:
						teleport {_minion} to (eye location of {_target}).add((a random number between -0.1 and 0.1), (a random number between -0.1 and 0.1), (a random number between -0.1 and 0.1))
				else:
					set {_teleportCD} to 2
			else if {_nameMinion} is "附魔飞刀":
				if {_target} is not {_owner}:
					set {_targetLoc} to (location of {_target}).add(eye location of {_target}).multiply(0.5)
					set {_mod} to 2
				else:
					set {_targetLoc} to (location of {_target}).add(0, 3.5, 0)
					set {_mod} to 1
				set {_index} to mod({_index}, {_mod})
				if {_index} = 0:
					set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
					vector length of {_dVec} > 0
					set vector length of {_dVec} to 0.75
				set velocity of {_minion} to {_dVec}
			else if {_nameMinion} is "小激光眼":
				add 1 to {_rotationIndex}
				set {_targetLoc} to (eye location of {_target}).add((sin({_rotationIndex} * 6) * 4), 2, (cos({_rotationIndex} * 6) * 4))
				set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
				vector length of {_dVec} > 0
				set vector length of {_dVec} to min((vector length of {_dVec} / 8), 1.5)
				teleport {_minion} to {_minionLoc}.add({_dVec})
				
				set {_index} to mod({_index}, 5)
				if {_index} is 0:
					{_target} is not {_owner}
					set {_v} to (eye location of {_target}).subtract(location of {_minion}).toVector()
					vector length of {_v} > 0
					set vector length of {_v} to 1.75
					set {_lazer} to mobProjectile({_minion}, {_v}, {_attrMap}, "激光")
					set gravity of {_lazer} to off
					set metadata "penetration" of {_lazer} to 1
					projectileAI({_lazer}, "GUN")
				#小魔焰眼
				if {_target} is not {_owner}:
					set {_targetLoc} to (eye location of {_target}).subtract(0, 0.5, 0)
					if mod({_index}, 4) is 0:
						set {_dVec} to {_targetLoc}.subtract(location of {_cousin}).toVector()
						vector length of {_dVec} > 0
						set vector length of {_dVec} to 2
						set velocity of {_cousin} to {_dVec}
					else if mod({_index}, 4) is 2:
						set {_dVec} to velocity of {_cousin}
						vector length of {_dVec} > 0
						set vector length of {_dVec} to 0.6
						set velocity of {_cousin} to {_dVec}
				else:
					set {_targetLoc} to (location of {_target}).add(0, 3.5, 0)
					if mod({_index}, 8) is 0:
						set {_dVecCousin} to {_targetLoc}.subtract(location of {_cousin}).toVector()
						vector length of {_dVecCousin} > 0
						set vector length of {_dVecCousin} to 1.5
					{_dVecCousin} is set
					teleport {_cousin} to (location of {_cousin}).add({_dVecCousin})
				makeTarget({_cousin}, {_target})
			else if {_nameMinion} is "矮人":
				set {_index} to 0
				{_target} is not {_owner}
				set {_v} to (eye location of {_target}).subtract(location of {_minion}).toVector()
				set {_dist} to vector length of {_v}
				{_dist} > 0
				set vector length of {_v} to 2
				set {_time} to {_dist} / 40
				set {_offSet} to {_time} * {_time} / 2
				add {_offSet} to y component of {_v}
				set {_bulletE} to {_minion}.getWorld().spawnEntity({_minion}.getEyeLocation(), EntityType.SNOWBALL)
				{_bulletE}.setCustomName("投矛")
				set metadata "attrMap" of {_bulletE} to {_attrMap}
				{_bulletE}.setVelocity({_v})
				{_bulletE}.setShooter({_minion})
				set metadata "penetration" of {_bulletE} to 1
				projectileAI({_bulletE}, "GUN")
			else if {_nameMinion} is "致命球":
				if {_target} is not {_owner}:
					if distance between location of {_minion} and location of {_target} > 32:
						set {_dV} to (eye location of {_target}).subtract(location of {_minion}).toVector()
						if vector length of {_dV} = 0:
							set {_dV} to vector(0, 1, 0)
						set vector length of {_dV} to 0.2
						{_dVec}.add({_dV})
						if vector length of {_dVec} > 1:
							set vector length of {_dVec} to 1
						set velocity of {_minion} to {_dVec}
						set {_index} to -1
					else:
						set {_index} to mod({_index}, 2)
						if {_index} = 0:
							set {_dVec} to (eye location of {_target}).subtract(location of {_minion}).toVector()
							if vector length of {_dVec} = 0:
								set {_dVec} to vector(0, 1, 0)
							set vector length of {_dVec} to 2
						else:
							add 0.75 to y of {_dVec}
						set velocity of {_minion} to {_dVec}
				else:
					set {_targetLoc} to (location of {_target}).add(0, 3.5, 0)
					set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
					vector length of {_dVec} > 0
					set vector length of {_dVec} to 1.5
					set velocity of {_minion} to {_dVec}
					set {_index} to -1
			else if {_nameMinion} is "星尘细胞":
				if {_target} is not {_owner}:
					subtract 1 from {_teleportCD}
					if {_teleportCD} < 0:
						set {_destination} to (eye location of {_target}).add(sin({_index}) * 2, 2, cos({_index}) * 2)
						set {_trailVec} to (eye location of {_minion}).subtract({_destination}).toVector()
						if vector length of {_trailVec} > 5:
							set vector length of {_trailVec} to 5
						handleParticleLine({_trailVec}, (vector length of {_trailVec}), 0.12, {_destination}, {_trailColor})
						teleport {_minion} to {_destination}
						set {_v} to (eye location of {_target}).subtract(eye location of {_minion}).toVector()
						if vector length of {_v} = 0:
							set {_v} to vector(0, 1, 0)
						set vector length of {_v} to 3
						set {_projectile} to mobProjectile({_minion}, {_v}, {_attrMap}, "星尘细胞弹")
						set gravity of {_projectile} to off
						set metadata "followTarget" of {_projectile} to {_target}
						projectileAI({_projectile}, "MAGIC")
						set {_teleportCD} to a random integer between 5 and 15
					set {_targetLoc} to eye location of {_target}
					if distance between location of {_minion} and {_targetLoc} > 12:
						set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
					else:
						set {_dVec} to (location of {_minion}).subtract({_targetLoc}).toVector()
						set pitch of {_dVec} to -30
					set vector length of {_dVec} to 0.5
					set {_index} to mod({_index}, 6)
					if {_index} = 0:
						set {_v} to (eye location of {_target}).subtract(eye location of {_minion}).toVector()
						if vector length of {_v} = 0:
							set {_v} to vector(0, 1, 0)
						set vector length of {_v} to 3
						set {_projectile} to mobProjectile({_minion}, {_v}, {_attrMap}, "星尘细胞弹")
						set gravity of {_projectile} to off
						set metadata "followTarget" of {_projectile} to {_target}
						projectileAI({_projectile}, "MAGIC")
				else:
					set {_teleportCD} to a random number between 5 and 10
					set {_targetLoc} to (location of {_target}).add(a random number between -1 and 1, a random number between 5 and 6, a random number between -1 and 1)
					if distance between location of {_minion} and {_targetLoc} > 2:
						set {_dVec} to {_targetLoc}.subtract(location of {_minion}).toVector()
						set vector length of {_dVec} to 0.7
				set velocity of {_minion} to {_dVec}
			else if {_nameMinion} is "星尘之龙":
				set metadata "meleeCD" of {_minion} to {_meleeCD}
				set {_index} to mod({_index}, 2)
				set {_i} to 0
				loop min({_minionIndex}, {_minionList}.size()) times:
					set {_loopMinion} to ({_minionList}.get({_i}))
					if trimText(name of {_loopMinion}) is "星尘之龙":
						# current minion is a body segment
						set {_i} to -1
						{_minion}.setCustomName("星尘之龙")
						set {_meleeCD} to metadata "meleeCD" of {_loopMinion}
						stop loop
					add 1 to {_i}
				if {_i} >= 0:
					# current minion is head segment
					clear {_segments::*}
					{_minion}.setCustomName("星尘之龙&1")
					set {_i} to {_minionIndex} + 1
					while {_i} < {_minionList}.size():
						set {_nextMinion} to ({_minionList}.get({_i}))
						if trimText(name of {_nextMinion}) is "星尘之龙":
							add {_nextMinion} to {_segments::*}
						add 1 to {_i}
					if {_target} is {_owner}:
						if distance between location of {_minion} and location of {_owner} > 25:
							clear {_v}
						if {_v} is not set:
							set {_v} to (eye location of {_target}).add(0, 4, 0).subtract(location of {_minion}).toVector()
							if vector length of {_v} = 0:
								set {_v} to vector(0, 1, 0)
						set vector length of {_v} to 0.75
					else:
						if {_index} = 0:
							set {_v} to (eye location of {_target}).subtract(eye location of {_minion}).toVector()
							if vector length of {_v} = 0:
								set {_v} to vector(0, 1, 0)
							set vector length of {_v} to min(((size of {_segments::*} + 1) * 1.25 + (vector length of {_v})) / 6, 2)
					if {_v} is set:
						set velocity of {_minion} to {_v}
					set {_dmg} to 80 * (1.69 + ((size of {_segments::*}) * 0.46))
					{_attrMap}.put("damage", {_dmg})
					loop {_segments::*}:
						set {_currentSeg} to loop-value
						(metadata "attrMap" of {_currentSeg}).put("damage", {_dmg})
					
					#follow head
					set {_lastLoc} to (location of {_minion}).add((velocity of {_minion}).multiply(3))
					loop {_segments::*}:
						set {_currentSeg} to loop-value
						set {_currLoc} to location of {_currentSeg}
						set {_segdVec} to {_lastLoc}.clone().subtract({_currLoc}).toVector()
						if vector length of {_segdVec} < 0.1:
							set {_segdVec} to vector(0, 1, 0)
						set vector length of {_segdVec} to 1.3
						set {_lastLoc} to {_lastLoc}.subtract({_segdVec})
						set {_segVel} to {_lastLoc}.clone().subtract(location of {_currentSeg}).toVector()
						if vector length of {_segVel} > 0.1:
							set vector length of {_segVel} to (vector length of {_segVel}) / 3
						set velocity of {_currentSeg} to {_segVel}
			else if {_nameMinion} is "泰拉棱镜":
				if {_target} is not {_owner}:
					set {_index} to mod({_index}, 8)
					set {_direction} to (eye location of {_target}).subtract(location of {_minion}).toVector()
					if vector length of {_direction} < 0.1:
						set {_direction} to vector(0, 1, 0)
					if {_index} = 0:
						if {_AItype} is "STAB":
							set {_AItype} to "SWING"
						else:
							set {_AItype} to "STAB"
					
					if {_AItype} is "STAB":
						if {_index} = 0:
							set {_dYaw} to 0
							set {_dPitch} to 0
							set {_dir} to (eye location of {_target}).subtract((location of {_minion}).add(0, 4, 0)).toVector()
							set {_yaw} to vector yaw of {_dir}
							set {_pitch} to vector pitch of {_dir}
							set {_vel} to vector(0, 0.5, 0)
						else if {_index} = 4:
							set {_vel} to {_direction}
							set vector length of {_vel} to (vector length of {_vel}) / 8
							set {_initialLoc} to location of {_minion}
						else if {_index} > 4:
							set {_dir} to (eye location of {_target}).subtract({_initialLoc}).toVector()
							set vector length of {_dir} to (vector length of {_dir}) * (7 - {_index}) / 4
							set {_vel} to (eye location of {_target}).subtract({_dir}).subtract(location of {_minion}).toVector()
							set vector length of {_vel} to (vector length of {_vel}) / (2 * (8 - {_index}))
					else:
						if {_index} = 0:
							set {_dYaw} to ((vector yaw of {_direction}) - {_yaw})
							set {_dPitch} to ((vector pitch of {_direction}) - {_pitch}) / 4
							if {_dYaw} < -180:
								add 360 to {_dYaw}
							else if {_dYaw} > 180:
								subtract 360 from {_dYaw}
							set {_dYaw} to {_dYaw} / 4
							
							set {_vel} to {_direction}
							set vector length of {_vel} to (vector length of {_vel}) / 6
				else:
					set {_AItype} to "SWING"
					set {_index} to -1
					set {_i} to 0
					set {_total} to 0
					loop {_minionList}.size() times:
						set {_checkMinion} to {_minionList}.get((loop-number) - 1)
						if {_checkMinion} is {_minion}:
							set {_i} to {_total}
						if name of {_checkMinion} is "泰拉棱镜":
							add 1 to {_total}
					set {_ownerYaw} to {_owner}.getHandle().yaw
					set {_targetYaw} to {_ownerYaw} + 90
					set {_targetPitch} to ({_i} * 360 / {_total}) - 90
					set {_dPos} to new vector with yaw {_targetYaw} and pitch {_targetPitch}
					set vector length of {_dPos} to 0.5
					set {_dV} to new vector with yaw {_ownerYaw} and pitch 0
					set vector length of {_dV} to 1
					set {_targetLoc} to (location of {_owner}).add(0, 1, 0).subtract({_dV}).add({_dPos})
					set {_vel} to {_targetLoc}.clone().subtract(location of {_minion}).toVector()
					if vector length of {_vel} > 0:
						if {_target} is {_owner}:
							set vector length of {_vel} to min(vector length of {_vel} / 4, 1)
						else:
							set vector length of {_vel} to 1
					if {_targetYaw} is set:
						set {_dYaw} to ({_targetYaw} - {_yaw})
						if {_dYaw} < -180:
							add 360 to {_dYaw}
						else if {_dYaw} > 180:
							subtract 360 from {_dYaw}
						set {_dYaw} to {_dYaw} / 5
						clear {_targetYaw}
					if {_targetPitch} is set:
						set {_dPitch} to ({_targetPitch} - {_pitch}) / 5
						clear {_targetPitch}
				add {_dYaw} to {_yaw}
				add {_dPitch} to {_pitch}
				set velocity of {_minion} to {_vel}
				handleStrikeLine({_minion}, {_yaw}, {_pitch}, 6, (a diamond), {_particleColor}, {_meleeCD}, true, {_null})
			makeTarget({_minion}, {_target})
		
		if {_attrMap}.get("damageType") is "Melee":
			set {_velocity} to velocity of {_minion}
			set {_dmgCD} to 5
			if {_nameMinion} is "星尘之龙":
				set {_checkHitTime} to 1
				set {_checkRadius} to 0.75
				set {_dmgCD} to 2
			else if {_nameMinion} is "蜘蛛":
				set {_checkHitTime} to 1
				set {_checkRadius} to 0.5
			else:
				set {_checkHitTime} to (floor((vector length of {_velocity}) * 4) + 1)
				set {_checkRadius} to 0.3
				if {_nameMinion} is "泰拉棱镜":
					set {_dmgCD} to 15
			loop {_checkHitTime} times:
				if loop-number > 1:
					set vector length of {_velocity} to (loop-number - 1) / 4
					set {_entities} to {_minion}.getWorld().getNearbyEntities({_minion}.getLocation().add(0.125, 0.125, 0.125).subtract({_velocity}), {_checkRadius}, {_checkRadius}, {_checkRadius})
				else if {_nameMinion} is "蜘蛛":
					set {_entities} to {_minion}.getWorld().getNearbyEntities({_minion}.getLocation().add(0.25, 0.125, 0.25), {_checkRadius}, {_checkRadius}, {_checkRadius})
				else:
					set {_entities} to {_minion}.getWorld().getNearbyEntities({_minion}.getLocation().add(0.125, 0.125, 0.125), {_checkRadius}, {_checkRadius}, {_checkRadius})
				loop ...{_entities}:
					set {_victim} to loop-value-2
					{_victim} is living entity
					{_victim} is not {_owner}
					{_meleeCD}.contains({_victim}) is false
					if checkCanDamage({_minion}, {_victim}) is not false:
						handleDamage({_victim}, {_minion}, {_attrMap}.get("damage"), "Melee")
						if {_nameMinion} is "蜘蛛":
							{_victim} is {_target}
							set {_teleport} to {_victim}
						damageCD({_meleeCD}, {_victim}, {_dmgCD})
		
		add 1 to {_index}
		add 1 to {_idx}
		if {_nameMinion} is "泰拉棱镜" or "蜘蛛":
			wait 2 ticks
		else if {_nameMinion} is "矮人":
			wait 12 ticks
		else:
			wait 3 ticks
	
	{_minionList}.remove({_minion})
	{_minion}.remove()
	{_cousin} is set
	{_cousin}.remove()
	