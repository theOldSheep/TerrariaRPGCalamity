import:
	com.destroystokyo.paper.event.entity.ProjectileCollideEvent
	java.util.ArrayList
	java.util.HashMap
	java.util.Random
	lk.vexview.api.VexViewAPI
	lk.vexview.tag.components.VexTextTag
	net.minecraft.server.v1_12_R1.AxisAlignedBB
	org.bukkit.entity.Arrow
	org.bukkit.entity.EntityType
	org.bukkit.entity.Projectile
	org.bukkit.event.entity.PotionSplashEvent
	org.bukkit.util.BlockIterator

function checkCanDamage(d: entity, v: entity) :: boolean:
	if {_v} has scoreboard tag "isPillar":
		if metadata "shield" of {_v} > 0:
			return false
	if {_v} is not a living entity:
		{_v} is not an armor stand
		return false
	if {_v} is a minecart:
		return false
	if {_v} has scoreboard tag "noDamage":
		return false
	if {_d} has scoreboard tag "ignoreCanDamageCheck":
		return true
	if shooter of {_d} is set:
		set {_d} to shooter of {_d}
	if metadata "damageSourcePlayer" of {_d} is set:
		set {_d} to metadata "damageSourcePlayer" of {_d}
		if {_d} is {_v}:
			return false
	if {_d} is a player:
		if {_v} is a player:
			gamemode of {_v} is survival
			{_d} is not {_v}
			{_d} has scoreboard tag "PVP"
			{_v} has scoreboard tag "PVP"
			return true
		else:
			set {_acc} to metadata "accessory" of {_d}
			if {_v} has scoreboard tag "isMonster":
				return true
			if {_v} has scoreboard tag "isNPC":
				return {_acc}.contains("%{_v}.getCustomName()%巫毒娃娃")
			if {_v} has scoreboard tag "isAnimal":
				if {_acc}.contains("小动物友谊指南"):
					return false
				return {null}
			return {null}
	else if {_v} is not a player:
		if {_d} has scoreboard tag "isMonster":
			{_v} doesn't have scoreboard tag "isMonster"
			return true
		else if {_d} has scoreboard tag "isNPC":
			{_v} has scoreboard tag "isMonster"
			return true
		else if {_v} has scoreboard tag "isMonster":
			return true
	else:
		gamemode of {_v} is survival
		if metadata "motherType" of {_d} is "史莱姆":
			set {_acc} to metadata "accessory" of {_v}
			if {_acc}.contains("皇家凝胶"):
				return false
		if {_d} doesn't have scoreboard tag "isNPC":
			return true
	return false
function checkMeleeTarget(v: entity) :: boolean:
	if {_v} is a living entity:
		return true
	else if {_v} has scoreboard tag "isMeleeTarget":
		return true
	return false

on damage:
	victim is a living entity
	cancel event
	set {_victim} to victim
	if {_victim} has scoreboard tag "isMount":
		damage cause is fall
		loop passengers of {_victim}:
			set {_victim} to loop-value
			stop loop
	set {_attrMap} to metadata "attrMap" of damager
	if ({_attrMap}.getOrDefault("damage", 0)) = 0:
		stop trigger
	if damage cause is fall:
		{_victim} has scoreboard tag "noFallDamage"
		stop trigger
	if "%{_victim}.getType()%" is "SLIME":
		damage cause is suffocation or fall
		stop trigger
	if "%damage cause%" is "cramming":
		if {_victim} doesn't have scoreboard tag "isNPC" or "isAnimal":
			if {_victim} is not a player:
				stop trigger
		set {_boundingBox} to {_victim}.getHandle().getBoundingBox()
		set {_length} to (({_boundingBox}.d) - ({_boundingBox}.a)) / 2
		set {_height} to (({_boundingBox}.e) - ({_boundingBox}.b)) / 2
		set {_width} to (({_boundingBox}.f) - ({_boundingBox}.c)) / 2
		set {_centerLoc} to location((({_boundingBox}.a) + {_length}), (({_boundingBox}.b) + {_height}), (({_boundingBox}.c + {_width})), (world of victim))

		set {_maxDmg} to 0
		set {_entities} to (world of {_victim}).getNearbyEntities({_centerLoc}, {_length}, {_height}, {_width})
		loop ...{_entities}:
			set {_curr} to loop-value
			if {_curr} has scoreboard tag "isMonster":
				checkCanDamage({_curr}, {_victim}) is not false
				health of {_curr} > 0
				{_curr} doesn't have scoreboard tag "noMelee"
				set {_attrMap} to metadata "attrMap" of {_curr}
				if {_attrMap}.getOrDefault("damage", 0) > {_maxDmg}:
					set {_maxDmg} to {_attrMap}.getOrDefault("damage", 0)
					set {_damager} to {_curr}
		if {_damager} is set:
			set {_dmgType} to "%{_attrMap}.get(""damageType"")%"
			if {_dmgType} is not "Melee":
				handleDamage({_victim}, {_damager}, (({_attrMap}.get("damage")) * 0.8), {_dmgType})
			else:
				handleDamage({_victim}, {_damager}, ({_attrMap}.get("damage")), {_dmgType})
	if "%damage cause%" is "attack" or "sweep attack":
		if damager has scoreboard tag "noMelee":
			stop trigger
		if name of damager contains "月球领主":
			damager doesn't have scoreboard tag "noDamage"
			stop trigger
		if damager is a player:
			if metadata "useCD" of damager is true:
				stop trigger
			playerUseItem(damager, (damager's tool))
			stop trigger
		if checkCanDamage(damager, {_victim}) is false:
			stop trigger
		set {_dmgType} to "%{_attrMap}.get(""damageType"")%"
		if {_dmgType} is not "Melee":
			handleDamage({_victim}, damager, (({_attrMap}.get("damage")) * 0.8), {_dmgType})
		else:
			handleDamage({_victim}, damager, ({_attrMap}.get("damage")), {_dmgType})
	else if damager is set:
		handleDamage({_victim}, damager, ({_attrMap}.get("damage")), "%{_attrMap}.get(""damageType"")%")
	else:
		if "%damage cause%" is "fall":
			{_victim} is a player
			set metadata "thrust" of {_victim} to 0
			set metadata "thrustProgress" of {_victim} to 0
		handleDamage({_victim}, damager, damage, "%damage cause%")
		damage cause is lava
		if {_victim} doesn't have scoreboard tag "isBOSS":
			{_victim} doesn't have scoreboard tag "noDamage"
			stop trigger
		wait 1 tick
		{_victim}.setFireTicks(200)

on ProjectileCollideEvent:
	cancel event
	set {_arrow} to event.getEntity()
	set {_entity} to event.getCollidedWith()
	if name of {_arrow} is "炸弹" or "粘性炸弹" or "雷管" or "粘性雷管":
		stop trigger
	if {_arrow} has scoreboard tag "isHook":
		stop trigger
	if {_entity} is a player:
		gamemode of {_entity} is not survival
		stop trigger
	if health of {_entity} <= 0:
		stop trigger
	if checkCanDamage({_arrow}, {_entity}) is false:
		stop trigger
	set {_attrMap} to (metadata "attrMap" of {_arrow}).clone()
	if {_entity} has scoreboard tag "reflectProjectile":
		set {_speed} to vector length of velocity of {_arrow}
		set {_velocity} to (eye location of (shooter of {_arrow})).subtract(location of {_arrow}).toVector()
		set vector length of {_velocity} to {_speed}
		set velocity of {_arrow} to {_velocity}
		{_arrow}.setShooter({_entity})
		play sound "ENTITY.IRONGOLEM.HURT" with volume 3 and pitch 1 at location of {_arrow}
		set metadata "collided" of {_arrow} to new ArrayList()
		stop trigger
	set {_collided} to metadata "collided" of {_arrow}
	if {_collided} is not set:
		set {_collided} to new ArrayList()
		set metadata "collided" of {_arrow} to {_collided}
	if {_collided}.contains({_entity}) is true:
		stop trigger
	else:
		damageCD({_collided}, {_entity}, 12)
	set {_penetration} to metadata "penetration" of {_arrow}
	set {_penetration} to {_penetration} parsed as integer
	if {_penetration} is not set:
		set {_penetration} to 0
	remove 1 from {_penetration}
	if {_penetration} < 0:
		if {_arrow} doesn't have scoreboard tag "isGranade":
			handleDamage({_entity}, {_arrow}, ({_attrMap}.get("damage")), "%{_attrMap}.get(""damageType"")%")
		handleProjectileDestroy({_arrow})
		{_arrow}.remove()
	else:
		handleDamage({_entity}, {_arrow}, ({_attrMap}.get("damage")), "%{_attrMap}.get(""damageType"")%")
		set metadata "penetration" of {_arrow} to {_penetration}
		teleport {_arrow} to (location of {_arrow}).subtract(velocity of {_arrow})
		{_attrMap}.put("damage", {_attrMap}.get("damage") * 0.96)
	
	if {_arrow} has scoreboard tag "isVortex":
		{_attrMap}.put("damage", ({_attrMap}.get("damage") * 0.3))
		{_attrMap}.put("knockback", 0)
		set {_shooter} to {_arrow}.getShooter()
		set {_projectileSpeed} to sqrt({_attrMap}.get("projectileSpeed"))
		wait "%a random integer between 3 and 5% ticks" parsed as timespan
		loop 3 times:
			set {_velocity} to (eye location of (event.getCollidedWith())).subtract({_shooter}.getLocation()).toVector()
			if vector length of {_velocity} = 0:
				set {_yaw} to {_shooter}.getHandle().yaw
				set {_pitch} to {_shooter}.getHandle().pitch
				set {_velocity} to new vector with yaw {_yaw} and pitch {_pitch}
			set vector length of {_velocity} to 17
			{_velocity}.add(vector(a random number between -1 and 1, a random number between -1 and 1, a random number between -1 and 1))
			set {_arrowE} to {_arrow}.getWorld().spawnEntity({_shooter}.getEyeLocation(), {_arrow}.getType())
			
			set vector length of {_velocity} to {_projectileSpeed}
			{_arrowE}.setCustomName("幻象箭")
			{_arrowE}.setGlowing(true)
			{_arrowE}.setGravity(false)
			{_arrowE}.setVelocity({_velocity})
			{_arrowE}.setShooter({_shooter})
			play sound "item.bowShoot" with volume 1 and pitch 1 at location of {_shooter}
			set metadata "attrMap" of {_arrowE} to {_attrMap}
			projectileAI({_arrowE}, "ARROW")
			wait "%a random integer between 4 and 8% ticks" parsed as timespan
	
function holyArrow(arrow: entity):
	set {_attrMap} to (metadata "attrMap" of {_arrow}).clone()
	{_attrMap}.put("knockbackMulti", 0.3)
	set {_shooter} to {_arrow}.getShooter()
	set {_projectileSpeed} to sqrt({_attrMap}.get("projectileSpeed"))
	set {_targetLoc} to location of {_arrow}
	loop 2 times:
		set {_originLoc} to {_targetLoc}.clone().add((a random number between -15 and 15), (a random number between 25 and 30), (a random number between -15 and 15))
		set {_velocity} to {_targetLoc}.clone().add(0, a random number between -3 and 3, 0).subtract({_originLoc}).toVector()
		set {_star} to {_arrow}.getWorld().spawnEntity({_originLoc}, EntityType.SPLASH_POTION)
		
		set vector length of {_velocity} to {_projectileSpeed}
		{_star}.setCustomName("落星")
		{_star}.setGravity(false)
		{_star}.setVelocity({_velocity})
		{_star}.setShooter({_shooter})
		disguiseProjectile({_star})
		set metadata "attrMap" of {_star} to {_attrMap}
		projectileAI({_star}, "GUN")
		wait "%a random integer between 6 and 10% ticks" parsed as timespan
	
on shoot:
	shooter of projectile has scoreboard tag "isMonster"
	set metadata "attrMap" of projectile to metadata "attrMap" of shooter of projectile
	if name of shooter of projectile is "精灵弓箭手":
		projectile.setCustomName("烈焰箭")
	else:
		projectile.setCustomName("木箭")
on PotionSplashEvent:
	cancel event
on projectile hit:
	set {_block} to event.getHitBlock()
	set {_arrow} to event.getEntity()
	{_block} is set
	if {_arrow} has scoreboard tag "isHook":
		stop trigger
	if "%{_block}.getType()%" is "LONG_GRASS" or "DOUBLE_PLANT" or "VINE" or "YELLOW_FLOWER" or "RED_ROSE" or "SNOW":
		set block at location of {_block} to air
		set {_arrow}.getHandle().dead to false
	else:
		if {_arrow} has scoreboard tag "thruWall":
			if {_arrow} has metadata "thruWallHeight":
				set {_height} to metadata "thruWallHeight" of {_arrow}
				if y-coordinate of {_arrow} > {_height}:
					y component of (velocity of {_arrow}) < 0
					set {_arrow}.getHandle().dead to false
					stop trigger
				else:
					y component of (velocity of {_arrow}) > 0
					set {_arrow}.getHandle().dead to false
					stop trigger
			else:
				set {_arrow}.getHandle().dead to false
				stop trigger
		else:
			{_arrow}.remove()
		set {_bounce} to metadata "Bounce" of {_arrow}
		set {_bounce} to {_bounce} parsed as integer
		remove 1 from {_bounce}
		if {_bounce} >= 0:
			set {_bounceSpawnLoc} to location of {_arrow}
			if name of {_arrow} is "绿藻弹" or "亡魂":
				{_arrow} doesn't have metadata "followTarget"
				{_arrow}.remove()
				stop trigger
			set {_v} to velocity of {_arrow}
			set {_arrowLoc} to location of {_arrow}
			if {_arrow}.getCustomName() is "叶绿箭":
				set {_v} to {_v}.multiply(-1)
				set {_speed} to vector length of {_v}
				loop all living entities in radius 24 of {_arrow}:
					checkCanDamage({_arrow}, loop-value) is true
					health of loop-value > 0
					set {_dir} to (eye location of loop-value).subtract(location of {_arrow}).toVector()
					set {_dist} to vector length of {_dir}
					set {_time} to ({_dist} / {_speed}) / 20
					set {_offSet} to {_time} * {_time} / 2
					add {_offSet} to y component of {_dir}
					set {_canReach} to true
					set {_bi} to new BlockIterator((world of {_arrow}), {_arrowLoc}.toVector(), {_dir}, 0, max({_dist} / 2, 1))
					while {_bi}.hasNext():
						set {_bNext} to {_bi}.next()
						if {_bNext} is solid:
							set {_canReach} to false
							stop loop
					if {_canReach} is true:
						set {_lastLoc} to location of loop-value
						wait 1 tick
						set {_velocityOffSet} to (location of loop-value).subtract({_lastLoc}).toVector()
						set {_dir} to (eye location of loop-value).subtract(location of {_arrow}).toVector()
						{_dir}.add({_velocityOffSet}.multiply({_time} * 20))
						set {_dist} to vector length of {_dir}
						set vector length of {_dir} to {_speed}
						set {_time} to ({_dist} / {_speed}) / 20
						add ({_time} / 2) to y component of {_dir}
						set {_v} to {_dir}
						stop loop
			else:
				set {_bi} to new BlockIterator({_arrow}.getWorld(), {_arrowLoc}.toVector(), {_v}, 0, 3)
				while {_bi}.hasNext():
					set {_bNext} to {_bi}.next()
					if {_bNext} is not event.getHitBlock():
						set {_block} to {_bNext}
					else:
						stop loop
				
				set {_blockFace} to event.getHitBlock().getFace({_block}).toString()
				#Get blockface, bounce off
				if {_blockFace} is "EAST" or "WEST":
					set x of {_v} to -1 * x of {_v}
				else if {_blockFace} is "UP" or "DOWN":
					set y of {_v} to -1 * y of {_v}
				else if {_blockFace} is "SOUTH" or "NORTH":
					set z of {_v} to -1 * z of {_v}
				set vector length of {_v} to vector length of velocity of {_arrow}
				if {_arrow} has scoreboard tag "isGranade":
					if {_arrow}.getCustomName() starts with "粘性":
						set gravity of {_arrow} to off
						set {_v} to vector(0, 0, 0)
					else:
						set (vector length of {_v}) to (vector length of {_v}) * 0.5
				else if {_arrow}.getCustomName() is "尖刺球":
					set vector length of {_v} to vector length of {_v} * 0.75
			#New arrow
			set {_newArrow} to {_arrow}.getWorld().spawnEntity({_bounceSpawnLoc}, {_arrow}.getType())
			{_newArrow}.setCustomName({_arrow}.getCustomName())
			set metadata "attrMap" of {_newArrow} to metadata "attrMap" of {_arrow}
			disguiseProjectile({_newArrow})
			{_newArrow}.setVelocity({_v})
			{_newArrow}.setShooter({_arrow}.getShooter())
			if gravity of {_arrow} is off:
				set gravity of {_newArrow} to off
			set scoreboard tags of {_newArrow} to scoreboard tags of {_arrow}
			set metadata "pSpeed" of {_newArrow} to vector length of {_v}
			set metadata "pType" of {_newArrow} to metadata "pType" of {_arrow}
			set metadata "followTarget" of {_newArrow} to metadata "followTarget" of {_arrow}
			set metadata "collided" of {_newArrow} to new ArrayList()
			set metadata "penetration" of {_newArrow} to metadata "penetration" of {_arrow}
			set metadata "Bounce" of {_newArrow} to {_bounce}
			{_newArrow}.setTicksLived({_arrow}.getTicksLived())
			projectileAI({_newArrow}, metadata "pType" of {_arrow})
		else:
			handleProjectileDestroy({_arrow})

function handleProjectileDestroy(arrow: entity):
	if {_arrow}.getCustomName() is "圣箭":
		holyArrow({_arrow})
	else if {_arrow}.getCustomName() is "坠星":
		{_arrow} has scoreboard tag "isFallenStar"
		set {_item} to getItem("坠星")
		drop {_item} at location of {_arrow}
		set glowing of dropped item to on
		{fallenStars}.add(dropped item)
	if {_arrow} has scoreboard tag "isGranade":
		#grenade
		handleEntityExplode({_arrow}, {_arrow})
	set {_clusterInfo} to yml value "%{_arrow}.getCustomName()%.clusterBomb" from file "plugins/Data/entities.yml"
	if {_clusterInfo} is set:
		set {_clusterAmount} to {_clusterInfo}.get("amount")
		set {_clusterName} to {_clusterInfo}.get("name")
		set {_clusterVelocity} to {_clusterInfo}.get("velocity")
		set {_damageMulti} to {_clusterInfo}.get("damageMulti")
		set {_shooter} to {_arrow}.getShooter()
		set {_spawnLoc} to location of {_arrow}
		set {_attrMap} to (metadata "attrMap" of {_arrow}).clone()
		set {_baseV} to velocity of {_arrow}
		set vector length of {_baseV} to {_clusterVelocity} * 0.66
		{_attrMap}.put("damage", {_attrMap}.get("damage") * {_damageMulti})
		loop {_clusterAmount} times:
			set {_v} to vector((a random number between -1 and 1), (a random number between -1 and 1), (a random number between -1 and 1))
			set vector length of {_v} to {_clusterVelocity}
			set {_v} to {_baseV}.clone().add({_v})
			set {_arrowE} to (world of {_arrow}).spawnEntity({_spawnLoc}, EntityType.SPLASH_POTION)
			{_arrowE}.setCustomName({_clusterName})
			{_arrowE}.setVelocity({_v})
			{_arrowE}.setShooter({_shooter})
			disguiseProjectile({_arrowE})
			set metadata "attrMap" of {_arrowE} to {_attrMap}
			if {_clusterName} is "集束破片":
				add "isGranade" to scoreboard tags of {_arrowE}
			projectileAI({_arrowE}, "ARROW")

on script load:
	set {Holograms} to new HashMap()
	set {NextHologramIndex} to 0
on stop:
	set {_loop} to {Holograms}.keySet()
	set {_index} to 0
	while {_index} < {_loop}.size():
		VexViewAPI.removeWorldTag({Holograms}.get({_loop}.get({_index})), {_loop}.get({_index}))
		add 1 to {_index}