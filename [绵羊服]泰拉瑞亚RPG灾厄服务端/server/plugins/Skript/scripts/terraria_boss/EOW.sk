import:
	java.util.ArrayList
	java.util.HashMap
	net.minecraft.server.v1_11_R1.BossBattle
	net.minecraft.server.v1_11_R1.BossBattle$BarColor
	net.minecraft.server.v1_11_R1.BossBattle$BarStyle
	net.minecraft.server.v1_11_R1.BossBattleServer
	net.minecraft.server.v1_11_R1.PacketPlayOutBoss$Action
	net.minecraft.server.v1_11_R1.PathfinderGoalFloat
	net.minecraft.server.v1_11_R1.PathfinderGoalSelector
	org.bukkit.craftbukkit.v1_11_R1.util.CraftChatMessage
	org.bukkit.entity.EntityType

on rightclick:
	gamemode of player is survival
	set {_tool} to player's tool
	if trimText(name of {_tool}) is "虫饵":
		if {BOSS}.containsKey("世界吞噬者"):
			stop trigger
		"%biome of location of player%" contains "mushroom"
		applyCD(player, 20)
		set {_tool} to (item amount of {_tool} - 1) of {_tool}
		set player's tool to {_tool}
		broadcast "&d&l世界吞噬者 苏醒了！"
		set {_xOffset} to a random number between 20 and -20
		set {_zOffset} to 20 - abs({_xOffset})
		if chance of 0.5:
			set {_zOffset} to {_zOffset} * -1
		set {_spawnLoc} to (location of player).subtract({_xOffset}, 0, {_zOffset})
		set y-coordinate of {_spawnLoc} to -5
		play sound "entity.enderdragon.growl" with volume 10 and pitch 1 at {_spawnLoc}
		set {_attrMap} to new HashMap()
		{_attrMap}.put("crit", 0.04)
		{_attrMap}.put("damage", 144)
		{_attrMap}.put("damageMeleeMulti", 1)
		{_attrMap}.put("damageMulti", 1)
		{_attrMap}.put("damageType", "Melee")
		{_attrMap}.put("defence", 8)
		{_attrMap}.put("defenceMulti", 1)
		{_attrMap}.put("knockback", 2)
		{_attrMap}.put("knockbackResistance", 1)
		{_attrMap}.put("knockbackMeleeMulti", 1)
		{_attrMap}.put("knockbackMulti", 1)
		set {_attrMapBullet} to new HashMap()
		{_attrMapBullet}.put("crit", 0.04)
		{_attrMapBullet}.put("damage", 128)
		{_attrMapBullet}.put("damageArrowMulti", 1)
		{_attrMapBullet}.put("damageRangedMulti", 1)
		{_attrMapBullet}.put("damageMulti", 1)
		{_attrMapBullet}.put("damageType", "Arrow")
		{_attrMapBullet}.put("knockback", 2)
		{_attrMapBullet}.put("knockbackArrowMulti", 1)
		{_attrMapBullet}.put("knockbackRangedMulti", 1)
		{_attrMapBullet}.put("knockbackMulti", 1)
		set {_arlst} to new ArrayList(30)
		set {_bossbar} to new BossBattleServer(CraftChatMessage.fromString("世界吞噬者", true)[0], BarColor.GREEN, BarStyle.PROGRESS)
		{_bossbar}.setVisible(true)
		set {_goalSel} to new PathfinderGoalSelector((player's world).getHandle().methodProfiler)
		
		spawn a slime at {_spawnLoc}
		set {_eow} to spawned entity
		set {_eow}.getHandle().goalSelector to {_goalSel}
		set {_targets} to setupBossTarget({_eow}, 0, player, true, {_bossbar})
		{BOSS}.put("世界吞噬者", {_arlst})
		set metadata "attrMap" of {_eow} to {_attrMap}.clone()
		set metadata "targets" of {_eow} to {_targets}
		set metadata "bossbar" of {_eow} to {_bossbar}
		set name of {_eow} to "世界吞噬者"
		{_arlst}.add(spawned entity)
		handleEOW({_eow}, player, 0, {_attrMapBullet})
		renderSingleBossbarAdvanced({_eow}, {_bossbar}, false)
		{_attrMap}.put("damage", 56)
		{_attrMap}.put("defence", 12)
		set {_index} to 0
		set {_length} to 69
		loop ({_length} - 1) times:
			spawn a slime at {_spawnLoc}
			set {_eow} to spawned entity
			set {_eow}.getHandle().goalSelector to {_goalSel}
			set metadata "attrMap" of {_eow} to {_attrMap}.clone()
			set metadata "targets" of {_eow} to {_targets}
			set metadata "bossbar" of {_eow} to {_bossbar}
			set name of {_eow} to "世界吞噬者"
			{_arlst}.add(spawned entity)
			add 1 to {_index}
			handleEOW({_eow}, player, {_index}, {_attrMapBullet})
			renderSingleBossbarAdvanced({_eow}, {_bossbar}, false)
		{_attrMap}.put("damage", 46)
		{_attrMap}.put("defence", 20)
		spawn a slime at {_spawnLoc}
		set {_eow} to spawned entity
		set {_eow}.getHandle().goalSelector to {_goalSel}
		set metadata "attrMap" of {_eow} to {_attrMap}.clone()
		set metadata "targets" of {_eow} to {_targets}
		set metadata "bossbar" of {_eow} to {_bossbar}
		set name of {_eow} to "世界吞噬者"
		{_arlst}.add(spawned entity)
		handleEOW({_eow}, player, {_length}, {_attrMapBullet})
		renderSingleBossbarAdvanced({_eow}, {_bossbar}, false)
		
		wait 3 ticks
		set {_totalHealth} to 0
		set {_index} to 0
		while {_index} < {_arlst}.size():
			add max health of {_arlst}.get({_index}) to {_totalHealth}
			add 1 to {_index}
		
		set {_currentHealth} to {_totalHealth}
		while {_currentHealth} > 0:
			set {_currentHealth} to 0
			set {_index} to 0
			while {_index} < {_arlst}.size():
				add health of {_arlst}.get({_index}) to {_currentHealth}
				add 1 to {_index}
			{_bossbar}.setProgress({_currentHealth} / {_totalHealth})
			wait 5 ticks
		{_bossbar}.setVisible(false)
		{BOSS}.remove("世界吞噬者")
		#drop
		max health of {_arlst}.get(0) is not 1
		broadcast "&d&l世界吞噬者 被击败了."
		set {_killers} to {_targets}.keySet().iterator()
		set {_drop} to a leather named "&r专家模式福袋" with lore "&7世界吞噬者"
		while {_killers}.hasNext():
			set {_ply} to {_killers}.next()
			set {_player} to {_ply} parsed as player
			name of {_player} is {_ply}
			set {_tier} to metadata "tier" of {_player}
			if {_targets}.get({_ply}) * 5 > ({_totalHealth}) / ({_targets}.size()):
				if {_tier} <= 1:
					set metadata "tier" of {_player} to 2
					set yml value "stats.tier" from file "plugins/PlayerData/%name of {_player}%.yml" to 2
					add "waitingForMeteorShower" to scoreboard tags of {_player}
				if {_player} can hold {_drop}:
					send "&a恭喜你击败了BOSS[&r世界吞噬者&a]!您的战利品已经放在背包里了。" to {_player}
					give {_drop} to {_player}
				else:
					send "&a恭喜你击败了BOSS[&r世界吞噬者&a]!您的背包空间不足以容纳战利品，请迅速拾起脚下的战利品袋，以免丢失。" to {_player}
					drop {_drop} at {_player}.getEyeLocation() without velocity
			else:
				send "&aBOSS 世界吞噬者 已经被击败。很遗憾，您的输出不足以获得一份战利品。" to {_player}

function handleEOW(eow: entity, ply: player, index: integer, bulletAttrMap: object):
	set {_segments} to {BOSS}.get("世界吞噬者")
	set {_attrMap} to metadata "attrMap" of {_eow}
	
	set {_targets} to metadata "targets" of {_eow}
	set {_healthMulti} to getBossHealthMulti({_targets}.size())
	{_eow}.setInvulnerable(true)
	set name of {_eow} to "世界吞噬者"
	add "isMonster" to scoreboard tags of {_eow}
	add "isBOSS" to scoreboard tags of {_eow}
	{_eow}.setCustomName("世界吞噬者")
	{_eow}.setCustomNameVisible(true)
	
	{_eow}.setGravity(false)
	{_eow}.setRemoveWhenFarAway(false)
	{_eow}.setSize(3)
	
	if {_index} = 0:
		set {_indexAI} to 0
	else:
		set {_indexAI} to a random integer between 0 and 499
		makeTarget({_eow}, {_segments}.get({_index} - 1))
	set {_bufferVec} to vector(0, 0, 0)
	set {_charging} to true
	
	wait 1 tick
	{_eow}.setInvulnerable(false)
	set max health of {_eow} to round(700 * {_healthMulti})
	set health of {_eow} to round(700 * {_healthMulti})
	
	set {_target} to {_ply}
	set {_totalTickSeg} to {_segments}.size() - 1
	
	while health of {_eow} > 0:
		{_eow}.setVelocity({_eow}.getVelocity().zero())
		set {_loc} to {_eow}.getLocation()
		{_bossbar}.setProgress[float](health of {_eow} / max health of {_eow})
		
		#AI types - head to determine the way to go, body to follow
		set {_AIType} to "Head"
		if {_index} > 0:
			if health of {_segments}.get({_index} - 1) > 0:
				set {_AIType} to "Follow"
		if {_AIType} is "Head":
			{_attrMap}.put("damage", 114)
			{_attrMap}.put("defence", 8)
		set {_isTail} to false
		if {_index} = {_segments}.size() - 1:
			set {_isTail} to true
			{_attrMap}.put("damage", 46)
			{_attrMap}.put("defence", 20)
		else if health of {_segments}.get({_index} + 1) <= 0:
			set {_isTail} to true
			{_attrMap}.put("damage", 46)
			{_attrMap}.put("defence", 20)
		
		if {_AIType} is "Head":
			#head
			if {_isTail}:
				set health of {_eow} to 0
				stop loop
			#clear invalid targets
			if {_target} is set:
				if checkBossTarget({_target}, {_eow}, false) is false:
					clear {_target}
				else if "%biome of location of {_target}%" doesn't contain "mushroom":
					clear {_target}
			
			#body segments after it
			set {_i} to {_index} + 1
			set {_totalTickSeg} to 0
			while {_i} < {_segments}.size():
				set {_followSeg} to {_segments}.get({_i})
				if health of {_followSeg} <= 0:
					set {_i} to {_segments}.size()
				else:
					add 1 to {_totalTickSeg}
					if {_i} + 1 = {_segments}.size():
						set {_relativeNext} to {_followSeg}
					else if health of {_segments}.get({_i} + 1) <= 0:
						set {_relativeNext} to {_followSeg}
					else:
						set {_relativeNext} to {_segments}.get({_i} + 1)
					set {_lastLoc} to {_segments}.get({_i} - 1).getLocation()
					set {_currLoc} to location of {_followSeg}
					set {_nextLoc} to location of {_relativeNext}
					
					set {_segdVec} to {_lastLoc}.clone().subtract({_nextLoc}).toVector()
					if vector length of {_segdVec} > 0:
						set vector length of {_segdVec} to 0.1
						set {_baseVec} to {_lastLoc}.clone().subtract({_currLoc}).toVector()
						vector length of {_baseVec} > 0
						set vector length of {_baseVec} to 1
						set {_deltaVec} to {_segdVec}.add({_baseVec})
						vector length of {_deltaVec} > 0
						set vector length of {_deltaVec} to 1.53
						set {_currLoc} to {_lastLoc}.clone().subtract({_deltaVec})
						teleport {_followSeg} to {_currLoc}
					add 1 to {_i}
			if {_target} is not set:
				loop toSkList {_targets}.keySet():
					set {_ply} to "%loop-value%" parsed as player
					"%biome of location of {_ply}%" contains "mushroom"
					checkBossTarget({_ply}, {_eow}, false) is true
					set {_target} to {_ply}
					makeTarget({_eow}, {_target})
					stop loop
				#find new target if avaliable, otherwise flee
			if {_target} is not set:
				{_loc}.subtract(0, 5, 0)
				if {_loc}.getY() < 0:
					set max health of {_segments}.get(0) to 1
					set {_i} to 0
					while {_i} < {_segments}.size():
						set {_followSeg} to {_segments}.get({_i})
						set max health of {_followSeg} to 1
						set health of {_followSeg} to 0
						{_followSeg}.remove()
						add 1 to {_i}
					stop loop
				teleport {_eow} to {_loc}
			else:
				#head AI
				if {_dVec} is not set:
					set {_indexAI} to 0
				else if distance between {_eow} and {_target} > 60:
					set {_indexAI} to 0
				set {_indexAI} to mod({_indexAI}, 60)
				if {_indexAI} = 0:
					set {_charging} to true
				set {_shouldIncreaseIdx} to true
				if {_indexAI} < 25:
					if {_charging} is true:
						if distance between {_eow} and {_target} < 8:
							set {_charging} to false
						else:
							set {_targetLoc} to eye location of {_target}
							set {_dVec} to ({_targetLoc}.subtract({_loc})).toVector()
							if (vector length of {_dVec}) < 0.01:
								set {_dVec} to vector(0, 1, 0)
							set vector length of {_dVec} to 0.5
							set {_shouldIncreaseIdx} to false
					else:
						set vector length of {_dVec} to (vector length of {_dVec}) * 0.975
						subtract 0.025 from y component of {_dVec}
				else:
					if (y-coordinate of {_eow}) > (y-coordinate of {_target}):
						set {_shouldIncreaseIdx} to false
					else:
						set {_targetLoc} to (location of {_target}).subtract(0, 20, 0)
						set {_dVec} to ({_targetLoc}.subtract({_loc})).toVector()
						if (vector length of {_dVec}) < 0.01:
							set {_dVec} to vector(0, -1, 0)
						set vector length of {_dVec} to 0.35
					set vector length of {_dVec} to (vector length of {_dVec}) * 0.95
					subtract 0.05 from y component of {_dVec}
				{_bufferVec}.add({_dVec})
				if vector length of {_bufferVec} > 1.2:
					set vector length of {_bufferVec} to 1.2
				set {_effVec} to {_bufferVec}.clone()
				if vector length of {_effVec} < 0.01:
					set {_effVec} to vector(1, 0, 0)
				set vector length of {_effVec} to 1.5 * (min(3 / min({_totalTickSeg} / 10, 3), 2))
				{_loc}.add({_effVec})
				teleport {_eow} to {_loc}
				if {_shouldIncreaseIdx} is true:
					add 1 to {_indexAI}
		else:
			#Body
			{_isTail} is false
			#spit
			add 1 to {_indexAI}
			if y-coordinate of {_eow} <= 50:
				set {_indexAI} to mod({_indexAI}, 200)
			else:
				set {_indexAI} to mod({_indexAI}, 75)
			if {_indexAI} = 0:
				EOWProjectile({_eow}, {_target}, {_bulletAttrMap})
		if block at {_loc} is not air or water or lava:
			play sound "item.shovel.flatten" with volume 1 and pitch 0.9 at {_loc}
		wait 2 ticks

function EOWProjectile(eow: entity, target: player, bulletAttrMap: object):
	set {_velocity} to (eye location of {_target}).subtract(eye location of {_eow}).toVector()
	set {_bulletE} to {_eow}.getWorld().spawnEntity((eye location of {_eow}), EntityType.SPLASH_POTION)
	
	set vector length of {_velocity} to 1
	{_bulletE}.setCustomName("魔唾液")
	{_bulletE}.setVelocity({_velocity})
	{_bulletE}.setShooter({_eow})
	add "isMeleeTarget" to scoreboard tags of {_bulletE}
	
	set metadata "attrMap" of {_bulletE} to {_bulletAttrMap}
	set metadata "collided" of {_bulletE} to new ArrayList()
	
	disguiseProjectile({_bulletE})
	projectileAI({_bulletE}, "GUN")
	{_bulletE}.setGravity(false)
	wait 1.7 seconds
	{_bulletE}.setGravity(true)