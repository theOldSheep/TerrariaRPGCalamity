import:
	java.util.ArrayList
	java.util.HashMap
	net.minecraft.server.v1_11_R1.BossBattle
	net.minecraft.server.v1_11_R1.BossBattle$BarColor
	net.minecraft.server.v1_11_R1.BossBattle$BarStyle
	net.minecraft.server.v1_11_R1.BossBattleServer
	net.minecraft.server.v1_11_R1.PacketPlayOutBoss$Action
	org.bukkit.craftbukkit.v1_11_R1.util.CraftChatMessage
	org.bukkit.entity.EntityType
	org.bukkit.entity.Item
	org.bukkit.event.entity.EntityDamageEvent

on EntityDamageEvent:
	set {_victim} to event.getEntity()
	"%{_victim}.getType()%" is "DROPPED_ITEM"
	set {_damageCause} to "%event.getCause()%"
	if {_damageCause} is "CONTACT":
		cancel event
		stop trigger
	{_damageCause} is "FIRE" or "BURNING" or "LAVA"
	set {_itemType} to uncoloured (name of (item of {_victim}))
	if {_itemType} contains "的 ":
		set {_info::*} to {_itemType} split at "的 "
		set {_itemType} to {_info::2}
	set {_rarity} to yml value "%{_itemType}%.rarity" from file "plugins/Data/items.yml"
	if {_rarity} > 0:
		cancel event
		stop trigger
	{_itemType} is "向导巫毒娃娃"
	"%world of {_victim}%" is "world_nether"
	{NPC}.get("向导").getWorld().getChunkAt({NPC}.get("向导").getLocation()).load()
	set {_player} to metadata "dropper" of {_victim}
	if {_player} is not set:
		set {_minDist} to 999
		loop all players:
			set {_currPly} to loop-player
			world of {_currPly} is world of {_victim}
			distance between {_currPly} and {_victim} < {_minDist}
			set {_player} to {_currPly}
			set {_minDist} to distance between {_currPly} and {_victim}
	set {_dVec} to (location of {_victim}).subtract(location of {_player}).toVector()
	set y of {_dVec} to 0
	if vector length of {_dVec} < 0.1:
		set {_dVec} to vector(0, 0, 1)
	set vector length of {_dVec} to 26
	set {_loc} to (location of {_victim}).add({_dVec})
	wait 5 ticks
	{BOSS}.containsKey("血肉之墙") is false
	health of {NPC}.get("向导") > 0
	handleDamage({NPC}.get("向导"), {_noDamager}, 10000, "lava")
	spawn a slime at {_loc}
	set {_wlf} to spawned entity
	spawn a slime at {_loc}
	set {_eyeTop} to spawned entity
	spawn a slime at {_loc}
	set {_eyeBottom} to spawned entity
	handleWLF({_wlf}, {_player}, {_eyeTop}, {_eyeBottom})

function handleWLF(wlf: entity, ply: player, eyeTop: entity, eyeBottom: entity):
	broadcast "&d&l血肉之墙 苏醒了！"
	play sound "entity.enderdragon.growl" with volume 10 and pitch 1 at location of {_wlf}
	set {_attrMapLazer} to new HashMap(10)
	{_attrMapLazer}.put("crit", 0.04)
	{_attrMapLazer}.put("damage", 50)
	{_attrMapLazer}.put("damageBulletMulti", 1)
	{_attrMapLazer}.put("damageRangedMulti", 1)
	{_attrMapLazer}.put("damageMulti", 1)
	{_attrMapLazer}.put("damageType", "Bullet")
	{_attrMapLazer}.put("knockback", 1)
	{_attrMapLazer}.put("knockbackBulletMulti", 1)
	{_attrMapLazer}.put("knockbackRangedMulti", 1)
	{_attrMapLazer}.put("knockbackMulti", 1)
	set {_attrMap} to new HashMap(11)
	{_attrMap}.put("crit", 0.04)
	{_attrMap}.put("damage", 200)
	{_attrMap}.put("damageMeleeMulti", 1)
	{_attrMap}.put("damageMulti", 1)
	{_attrMap}.put("damageType", "Melee")
	{_attrMap}.put("defence", 25)
	{_attrMap}.put("defenceMulti", 1)
	{_attrMap}.put("knockback", 1)
	{_attrMap}.put("knockbackResistance", 1)
	{_attrMap}.put("knockbackMeleeMulti", 1)
	{_attrMap}.put("knockbackMulti", 1)
	set {_attrMapEye} to {_attrMap}.clone()
	{_attrMapEye}.put("defence", 10)
	{_attrMapEye}.put("damage", 44)
	set {_attrMapHungry} to {_attrMap}.clone()
	{_attrMapHungry}.put("knockbackResistance", 0)
	{_attrMapHungry}.put("defence", 20)
	{_attrMapHungry}.put("damage", 80)
	set metadata "attrMap" of {_wlf} to {_attrMap}
	set metadata "attrMap" of {_eyeTop} to {_attrMapEye}
	set metadata "attrMap" of {_eyeBottom} to {_attrMapEye}
	
	set {_bossbar} to new BossBattleServer(CraftChatMessage.fromString("血肉之墙", true)[0], BarColor.GREEN, BarStyle.PROGRESS)
	{_bossbar}.setVisible(true)
	set metadata "bossbar" of {_wlf} to {_bossbar}
	
	set {_targets} to setupBossTarget({_wlf}, 3, {_ply}, true, {_bossbar})
	set metadata "targets" of {_wlf} to {_targets}
	set metadata "targets" of {_eyeTop} to {_targets}
	set metadata "targets" of {_eyeBottom} to {_targets}
	set {_healthMulti} to getBossHealthMulti({_targets}.size())
	set name of {_wlf} to "血肉之墙"
	{_wlf}.setCustomName("血肉之墙&1")
	add "isMonster" to scoreboard tags of {_wlf}
	add "isBOSS" to scoreboard tags of {_wlf}
	{_wlf}.setCustomNameVisible(true)
	set name of {_eyeTop} to "血肉之墙"
	add "isMonster" to scoreboard tags of {_eyeTop}
	add "isBOSS" to scoreboard tags of {_eyeTop}
	{_eyeTop}.setCustomName("血肉之墙")
	{_eyeTop}.setCustomNameVisible(true)
	set name of {_eyeBottom} to "血肉之墙"
	add "isMonster" to scoreboard tags of {_eyeBottom}
	add "isBOSS" to scoreboard tags of {_eyeBottom}
	{_eyeBottom}.setCustomName("血肉之墙")
	{_eyeBottom}.setCustomNameVisible(true)
	add "healthPool" to scoreboard tags of {_eyeTop}
	add "healthPool" to scoreboard tags of {_eyeBottom}
	
	{_wlf}.setRemoveWhenFarAway(false)
	{_wlf}.setGravity(false)
	slimeResize({_wlf}, 8)
	{_eyeTop}.setRemoveWhenFarAway(false)
	{_eyeTop}.setGravity(false)
	slimeResize({_eyeTop}, 8)
	{_eyeBottom}.setRemoveWhenFarAway(false)
	{_eyeBottom}.setGravity(false)
	slimeResize({_eyeBottom}, 8)
	
	set {_bossArlst} to new ArrayList(3)
	{_bossArlst}.add({_wlf})
	{_bossArlst}.add({_eyeTop})
	{_bossArlst}.add({_eyeBottom})
	{BOSS}.put("血肉之墙", {_bossArlst})
	
	set {_health} to round(15000 * {_healthMulti})
	set max health of {_wlf} to {_health}
	set health of {_wlf} to {_health}
	set max health of {_eyeTop} to {_health}
	set health of {_eyeTop} to {_health}
	set max health of {_eyeBottom} to {_health}
	set health of {_eyeBottom} to {_health}
	set {_countAI} to 0
	set {_target} to {_ply}
	set metadata "target" of {_wlf} to {_target}
	set metadata "target" of {_eyeTop} to {_target}
	set metadata "target" of {_eyeBottom} to {_target}
	
	makeTarget({_wlf}, {_target})
	makeTarget({_eyeTop}, {_target})
	makeTarget({_eyeBottom}, {_target})
	renderSingleBossbar({_wlf}, {_bossbar})
	
	wait 1 tick
	
	set {_lazerCount} to 0
	set {_lazerCD} to 60
	set {_moveSpeed} to 0.15
	set {_mouthLoc} to location of {_wlf}
	set {_eyeTopLoc} to location of {_eyeTop}
	set {_eyeBottomLoc} to location of {_eyeBottom}
	set {_yMax} to 80
	set {_yMin} to 60
	
	loop 8 times:
		spawnHungry({_wlf}, {_attrMapHungry})
		spawnHungry({_eyeTop}, {_attrMapHungry})
		spawnHungry({_eyeBottom}, {_attrMapHungry})
	
	while health of {_wlf} > 0:
		#clear invalid targets
		if {_target} is set:
			checkBossTarget({_target}, {_wlf}, false) is false
			clear {_target}
			clear metadata "target" of {_wlf}
			clear metadata "target" of {_eyeTop}
			clear metadata "target" of {_eyeBottom}
		
		if {_target} is not set:
			loop toSkList {_targets}.keySet():
				set {_ply} to "%loop-value%" parsed as player
				checkBossTarget({_ply}, {_wlf}, false) is true
				set {_target} to {_ply}
				set metadata "target" of {_wlf} to {_target}
				set metadata "target" of {_eyeTop} to {_target}
				set metadata "target" of {_eyeBottom} to {_target}
				makeTarget({_wlf}, {_target})
				makeTarget({_eyeTop}, {_target})
				makeTarget({_eyeBottom}, {_target})
				stop loop
			#find new target if avaliable, otherwise flee
		if {_target} is not set:
			#flee
			set max health of {_wlf} to 1
			{_wlf}.remove()
			{_eyeTop}.remove()
			{_eyeBottom}.remove()
			stop loop
		else:
			#AI part starting here
			if {_moveDir} is not set:
				set {_moveDir} to (location of {_target}).subtract(location of {_wlf}).toVector()
				set y component of {_moveDir} to 0
				if vector length of {_moveDir} = 0:
					set {_moveDir} to vector(0, 0, 1)
			set health of {_eyeTop} to health of {_wlf}
			set health of {_eyeBottom} to health of {_wlf}
			
			if mod({_countAI}, 6) = 0:
				set {_healthPerc} to health of {_wlf} / max health of {_wlf}
				{_attrMapHungry}.put("damage", (200 - {_healthPerc} * 100))
				{_attrMapHungry}.put("defence", (50 - {_healthPerc} * 30))
				if {_healthPerc} < 0.025:
					set {_moveSpeed} to 1
				else if {_healthPerc} < 0.035:
					set {_moveSpeed} to 0.75
				else if {_healthPerc} < 0.05:
					set {_moveSpeed} to 0.6
				else if {_healthPerc} < 0.25:
					set {_moveSpeed} to 0.5
				else if {_healthPerc} < 0.33:
					set {_moveSpeed} to 0.4
				else if {_healthPerc} < 0.5:
					set {_moveSpeed} to 0.3
				else if {_healthPerc} < 0.66:
					set {_moveSpeed} to 0.25
				else if {_healthPerc} < 0.75:
					set {_moveSpeed} to 0.2
			if mod({_countAI}, 40) = 0:
				#fit into space in the nether
				set {_checkLoc} to location of {_wlf}
				set y-coordinate of {_checkLoc} to 65
				set {_hasSpace} to false
				loop 65 times:
					{_checkLoc}.subtract(0, 1, 0)
					if {_hasSpace}:
						if block at {_checkLoc} is not air:
							if block at {_checkLoc} is not air:
								set {_yMin} to y-coordinate of {_checkLoc}
								stop loop
					else if block at {_checkLoc} is air:
						set {_hasSpace} to true
				set y-coordinate of {_checkLoc} to 65
				set {_hasSpace} to false
				loop 65 times:
					{_checkLoc}.add(0, 1, 0)
					if {_hasSpace}:
						if block at {_checkLoc} is not air:
							if block at {_checkLoc} is not air:
								set {_yMax} to y-coordinate of {_checkLoc}
								stop loop
					else if block at {_checkLoc} is air:
						set {_hasSpace} to true
				set {_yDist} to {_yMax} - {_yMin}
			
			set vector length of {_moveDir} to {_moveSpeed}
			
			{_mouthLoc}.add({_moveDir})
			{_eyeTopLoc}.add({_moveDir})
			{_eyeBottomLoc}.add({_moveDir})
			set y-coordinate of {_mouthLoc} to ((y-coordinate of {_mouthLoc}) * 0.9) + (({_yMin} + ({_yDist} * 0.5)) / 10)
			teleport {_wlf} to {_mouthLoc}
			set y-coordinate of {_eyeTopLoc} to ((y-coordinate of {_eyeTopLoc}) * 0.9) + (({_yMin} + ({_yDist} * 0.75)) / 10)
			teleport {_eyeTop} to {_eyeTopLoc}
			set y-coordinate of {_eyeBottomLoc} to ((y-coordinate of {_eyeBottomLoc}) * 0.9) + (({_yMin} + ({_yDist} * 0.25)) / 10)
			teleport {_eyeBottom} to {_eyeBottomLoc}
			
			if mod({_countAI}, 17) = 0:
				loop all players in world of {_wlf}:
					distance between location of loop-player and location of {_wlf} < 200
					gamemode of loop-player is not spectator
					set {_playerVec} to (location of loop-player).subtract(location of {_wlf}).toVector()
					set y component of {_playerVec} to 0
					applyEffect(loop-player, "恐惧", 1200)
					if angle between {_moveDir} and {_playerVec} > 90:
						handleDamage(loop-player, {_wlf}, {_attrMap}.get("damage"), "Melee")
						push loop-player (location of {_wlf}).subtract(location of loop-player).toVector() at velocity 4.1
				#lick players behind
			if mod({_countAI}, 30) = 0:
				if chance of 0.5:
					spawnHungry({_wlf}, {_attrMapHungry})
				if chance of 0.5:
					spawnHungry({_eyeTop}, {_attrMapHungry})
				if chance of 0.5:
					spawnHungry({_eyeBottom}, {_attrMapHungry})
			if {_lazerCount} > 0:
				#lazer
				set {_velocity} to ({_target}.getEyeLocation().subtract({_eyeTop}.getEyeLocation())).toVector()
				set {_lazer} to {_eyeTop}.getWorld().spawnEntity({_eyeTop}.getEyeLocation(), EntityType.SPLASH_POTION)
				set vector length of {_velocity} to 1.25
				{_lazer}.setCustomName("激光")
				{_lazer}.setVelocity({_velocity})
				{_lazer}.setGravity(false)
				{_lazer}.setShooter({_eyeTop})
				set metadata "attrMap" of {_lazer} to {_attrMapLazer}
				set metadata "penetration" of {_lazer} to 10
				disguiseProjectile({_lazer})
				projectileAI({_lazer}, "GUN")
				set {_velocity} to ({_target}.getEyeLocation().subtract({_eyeBottom}.getEyeLocation())).toVector()
				set {_lazer} to {_eyeBottom}.getWorld().spawnEntity({_eyeBottom}.getEyeLocation(), EntityType.SPLASH_POTION)
				set vector length of {_velocity} to 1.25
				{_lazer}.setCustomName("激光")
				{_lazer}.setVelocity({_velocity})
				{_lazer}.setGravity(false)
				{_lazer}.setShooter({_eyeBottom})
				set metadata "attrMap" of {_lazer} to {_attrMapLazer}
				set metadata "penetration" of {_lazer} to 10
				disguiseProjectile({_lazer})
				projectileAI({_lazer}, "GUN")
				
				remove 1 from {_lazerCount}
				if {_lazerCount} <= 0:
					set {_lazerCD} to 12 - {_healthPerc} * 9
			else:
				remove 1 from {_lazerCD}
				if {_lazerCD} <= 0:
					set {_lazerCount} to 12 - {_healthPerc} * 9
					{_attrMapLazer}.put("damage", (100 - {_healthPerc} * 50))
			add 1 to {_countAI}
		wait 3 ticks
	{_bossbar}.setVisible(false)
	{BOSS}.remove("血肉之墙")
	set health of {_wlf} to 0
	set health of {_eyeTop} to 0
	set health of {_eyeBottom} to 0
	#drop
	set {_maxHealth} to max health of {_wlf}
	{_maxHealth} is not 1
	broadcast "&d&l血肉之墙 被击败了."
	set {_targets} to metadata "targets" of {_wlf}
	set {_killers} to {_targets}.keySet().iterator()
	set {_drop} to a leather named "&r专家模式福袋" with lore "&7血肉之墙"
	while {_killers}.hasNext():
		set {_ply} to {_killers}.next()
		set {_player} to {_ply} parsed as player
		name of {_player} is {_ply}
		set {_tier} to metadata "tier" of {_player}
		if {_targets}.get({_ply}) * 5 > ({_maxHealth}) / ({_targets}.size()):
			if {_tier} = 3:
				set metadata "tier" of {_player} to 4
				set yml value "stats.tier" from file "plugins/PlayerData/%name of {_player}%.yml" to 4
				send "&a古老的光明与黑暗之魂已经释放……" to {_player}
			if {_player} can hold {_drop}:
				send "&a恭喜你击败了BOSS[&r血肉之墙&a]!您的战利品已经放在背包里了。" to {_player}
				give {_drop} to {_player}
			else:
				send "&a恭喜你击败了BOSS[&r血肉之墙&a]!您的背包空间不足以容纳战利品，请迅速拾起脚下的战利品袋，以免丢失。" to {_player}
				drop {_drop} at {_player}.getEyeLocation() without velocity
		else:
			send "&aBOSS 血肉之墙 已经被击败。很遗憾，您的输出不足以获得一份战利品。" to {_player}

function spawnHungry(attatched: entity, attrMap: object):
	spawn a slime at location of {_attatched}
	set {_hungry} to spawned slime
	{_hungry}.setSize(3)
	set max health of {_hungry} to 500
	set health of {_hungry} to 500
	set metadata "attrMap" of {_hungry} to {_attrMap}
	set metadata "motherType" of {_hungry} to "饿鬼Attatched"
	{_hungry}.setGravity(false)
	{_hungry}.setCustomName("饿鬼")
	apply potion of fire resistance without particles to {_hungry} for 10 days
	wait "%a random integer between 0 and 10% ticks" parsed as timespan
	while health of {_hungry} > 0:
		if health of {_attatched} <= 0:
			{_hungry}.remove()
			stop trigger
		set {_target} to metadata "target" of {_attatched}
		makeTarget({_hungry}, {_target})
		if distance between location of {_hungry} and location of {_attatched} > 35:
			teleport {_hungry} to location of {_attatched}
		set {_v} to {_target}.getLocation().subtract({_attatched}.getLocation()).toVector()
		set vector length of {_v} to 14
		set {_destination} to {_attatched}.getLocation().add({_v})
		set {_v} to {_destination}.subtract({_hungry}.getLocation()).toVector()
		set {_distance} to vector length of {_v}
		set vector length of {_v} to 0.35
		set {_vTotal} to {_hungry}.getVelocity()
		{_vTotal}.add({_v})
		set vector length of {_vTotal} to max(sqrt({_distance} / 16), 0.25)
		{_hungry}.setVelocity({_vTotal})
		wait 10 ticks